// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"fmt"
	"github.com/google/wire"
	"github.com/traPtitech/trap-collection-server/src/auth/traQ"
	"github.com/traPtitech/trap-collection-server/src/cache/ristretto"
	"github.com/traPtitech/trap-collection-server/src/config"
	"github.com/traPtitech/trap-collection-server/src/config/v1"
	"github.com/traPtitech/trap-collection-server/src/handler"
	"github.com/traPtitech/trap-collection-server/src/handler/common"
	"github.com/traPtitech/trap-collection-server/src/handler/v2"
	"github.com/traPtitech/trap-collection-server/src/repository"
	"github.com/traPtitech/trap-collection-server/src/repository/gorm2"
	v1_2 "github.com/traPtitech/trap-collection-server/src/service/v1"
	v2_2 "github.com/traPtitech/trap-collection-server/src/service/v2"
	"github.com/traPtitech/trap-collection-server/src/storage"
	"github.com/traPtitech/trap-collection-server/src/storage/local"
	"github.com/traPtitech/trap-collection-server/src/storage/s3"
	"github.com/traPtitech/trap-collection-server/src/storage/swift"
)

// Injectors from storage.go:

func injectSwiftStorage(conf config.StorageSwift) (*Storage, error) {
	client, err := swift.NewClient(conf)
	if err != nil {
		return nil, err
	}
	gameImage := swift.NewGameImage(client)
	gameVideo := swift.NewGameVideo(client)
	gameFile := swift.NewGameFile(client)
	storage, err := newStorage(gameImage, gameVideo, gameFile)
	if err != nil {
		return nil, err
	}
	return storage, nil
}

func injectLocalStorage(conf config.StorageLocal) (*Storage, error) {
	directoryManager, err := local.NewDirectoryManager(conf)
	if err != nil {
		return nil, err
	}
	gameImage, err := local.NewGameImage(directoryManager)
	if err != nil {
		return nil, err
	}
	gameVideo, err := local.NewGameVideo(directoryManager)
	if err != nil {
		return nil, err
	}
	gameFile, err := local.NewGameFile(directoryManager)
	if err != nil {
		return nil, err
	}
	storage, err := newStorage(gameImage, gameVideo, gameFile)
	if err != nil {
		return nil, err
	}
	return storage, nil
}

func injectS3Storage(conf config.StorageS3) (*Storage, error) {
	client, err := s3.NewClient(conf)
	if err != nil {
		return nil, err
	}
	gameImage := s3.NewGameImage(client)
	gameVideo := s3.NewGameVideo(client)
	gameFile := s3.NewGameFile(client)
	storage, err := newStorage(gameImage, gameVideo, gameFile)
	if err != nil {
		return nil, err
	}
	return storage, nil
}

// Injectors from wire.go:

func InjectApp() (*App, error) {
	app := v1.NewApp()
	v1Handler := v1.NewHandler()
	session, err := common.NewSession(v1Handler)
	if err != nil {
		return nil, err
	}
	context := v2.NewContext()
	v2Session, err := v2.NewSession(session)
	if err != nil {
		return nil, err
	}
	serviceV2 := v1.NewServiceV2()
	authTraQ := v1.NewAuthTraQ()
	user, err := traq.NewUser(authTraQ)
	if err != nil {
		return nil, err
	}
	cacheRistretto := v1.NewCacheRistretto()
	ristrettoUser, err := ristretto.NewUser(cacheRistretto)
	if err != nil {
		return nil, err
	}
	v2User := v2_2.NewUser(user, ristrettoUser)
	oidc, err := traq.NewOIDC(authTraQ)
	if err != nil {
		return nil, err
	}
	v2OIDC, err := v2_2.NewOIDC(serviceV2, v2User, oidc)
	if err != nil {
		return nil, err
	}
	repositoryGorm2 := v1.NewRepositoryGorm2()
	db, err := gorm2.NewDB(app, repositoryGorm2)
	if err != nil {
		return nil, err
	}
	edition := gorm2.NewEdition(db)
	gameV2 := gorm2.NewGameV2(db)
	gameVersionV2 := gorm2.NewGameVersionV2(db)
	gameFileV2 := gorm2.NewGameFileV2(db)
	v2Edition := v2_2.NewEdition(db, edition, gameV2, gameVersionV2, gameFileV2)
	productKey := gorm2.NewProductKey(db)
	accessToken := gorm2.NewAccessToken(db)
	editionAuth := v2_2.NewEditionAuth(db, edition, productKey, accessToken)
	gameManagementRole := gorm2.NewGameManagementRole(db)
	gameRole := v2_2.NewGameRole(db, gameV2, gameManagementRole, v2User)
	adminAuth := gorm2.NewAdminAuth(db)
	v2AdminAuth := v2_2.NewAdminAuth(db, adminAuth, v2User)
	gameGenre := gorm2.NewGameGenre(db)
	game := v2_2.NewGame(db, gameV2, gameManagementRole, gameGenre, v2User)
	checker := v2.NewChecker(context, v2Session, v2OIDC, v2Edition, editionAuth, gameRole, v2AdminAuth, game)
	oAuth2, err := v2.NewOAuth2(v1Handler, v2Session, v2OIDC)
	if err != nil {
		return nil, err
	}
	userUtils := v1_2.NewUserUtils(user, ristrettoUser)
	v1User := v1_2.NewUser(userUtils)
	user2 := v2.NewUser(v2Session, v1User)
	admin := v2.NewAdmin(v2AdminAuth, v2Session)
	v2Game := v2.NewGame(v2Session, game)
	v2GameRole := v2.NewGameRole(gameRole, game, v2Session)
	v2GameGenre := v2_2.NewGameGenre(db, gameGenre)
	gameGenre2 := v2.NewGameGenre(v2GameGenre, game, v2Session)
	gameImageV2 := gorm2.NewGameImageV2(db)
	gameVideoV2 := gorm2.NewGameVideoV2(db)
	gameVersion := v2_2.NewGameVersion(db, gameV2, gameImageV2, gameVideoV2, gameFileV2, gameVersionV2)
	v2GameVersion := v2.NewGameVersion(gameVersion)
	storage := v1.NewStorage()
	storageSwift := v1.NewStorageSwift()
	storageLocal := v1.NewStorageLocal()
	storageS3 := v1.NewStorageS3()
	wireStorage, err := storageSwitch(storage, storageSwift, storageLocal, storageS3)
	if err != nil {
		return nil, err
	}
	gameFile := wireStorage.GameFile
	v2GameFile := v2_2.NewGameFile(db, gameV2, gameFileV2, gameFile)
	gameFile2 := v2.NewGameFile(v2GameFile)
	gameImage := wireStorage.GameImage
	v2GameImage := v2_2.NewGameImage(db, gameV2, gameImageV2, gameImage)
	gameImage2 := v2.NewGameImage(v2GameImage)
	gameVideo := wireStorage.GameVideo
	v2GameVideo := v2_2.NewGameVideo(db, gameV2, gameVideoV2, gameVideo)
	gameVideo2 := v2.NewGameVideo(v2GameVideo)
	edition2 := v2.NewEdition(v2Edition)
	v2EditionAuth := v2.NewEditionAuth(context, editionAuth)
	seat := gorm2.NewSeat(db)
	ristrettoSeat, err := ristretto.NewSeat(cacheRistretto)
	if err != nil {
		return nil, err
	}
	v2Seat := v2_2.NewSeat(db, seat, ristrettoSeat)
	seat2 := v2.NewSeat(v2Seat)
	api := v2.NewAPI(checker, v2Session, oAuth2, user2, admin, v2Game, v2GameRole, gameGenre2, v2GameVersion, gameFile2, gameImage2, gameVideo2, edition2, v2EditionAuth, seat2)
	handlerAPI, err := handler.NewAPI(app, v1Handler, session, api)
	if err != nil {
		return nil, err
	}
	wireApp := newApp(handlerAPI, db)
	return wireApp, nil
}

// storage.go:

var (
	storageSet = wire.NewSet(wire.FieldsOf(new(*Storage), "GameImage"), wire.FieldsOf(new(*Storage), "GameVideo"), wire.FieldsOf(new(*Storage), "GameFile"), storageSwitch)
)

type Storage struct {
	GameImage storage.GameImage
	GameVideo storage.GameVideo
	GameFile  storage.GameFile
}

func newStorage(
	gameImage storage.GameImage,
	gameVideo storage.GameVideo,
	gameFile storage.GameFile,
) (*Storage, error) {
	return &Storage{
		GameImage: gameImage,
		GameVideo: gameVideo,
		GameFile:  gameFile,
	}, nil
}

func storageSwitch(
	conf config.Storage,
	swiftConf config.StorageSwift,
	localConf config.StorageLocal,
	s3Conf config.StorageS3,
) (*Storage, error) {
	storageType, err := conf.Type()
	if err != nil {
		return nil, fmt.Errorf("failed to get storage type: %w", err)
	}

	switch storageType {
	case config.StorageTypeSwift:
		return injectSwiftStorage(swiftConf)
	case config.StorageTypeLocal:
		return injectLocalStorage(localConf)
	case config.StorageTypeS3:
		return injectS3Storage(s3Conf)
	}

	return nil, fmt.Errorf("unknown storage type: %d", storageType)
}

// wire.go:

type App struct {
	*handler.API
	repository.DB
}

func newApp(api *handler.API, db repository.DB) *App {
	return &App{
		API: api,
		DB:  db,
	}
}

func (app *App) Run() error {
	defer app.DB.Close()

	return app.API.Start()
}
