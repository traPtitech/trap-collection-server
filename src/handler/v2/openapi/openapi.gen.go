// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes                  = "AdminAuth.Scopes"
	EditionAuthScopes                = "EditionAuth.Scopes"
	EditionGameFileAuthScopes        = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes       = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes       = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes              = "EditionIDAuth.Scopes"
	GameCreatorsVisibilityAuthScopes = "GameCreatorsVisibilityAuth.Scopes"
	GameFileVisibilityAuthScopes     = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes    = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes     = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes         = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes              = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes    = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes             = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videom4v GameVideoMime = "video/m4v"
	Videomkv GameVideoMime = "video/mkv"
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionPlayStats エディションのプレイ統計データです。
type EditionPlayStats struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// EditionName エディション名です。
	EditionName EditionName `json:"editionName"`

	// GameStats エディションに含まれるゲームごとの統計データです。
	GameStats []GamePlayStatsInEdition `json:"gameStats"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameCreator defines model for GameCreator.
type GameCreator struct {
	Jobs []GameCreatorJob `json:"jobs"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// GameCreatorJob ゲームクリエイターのjob情報を表します。
// ユーザーが独自に定義したjobの場合、kindは指定されません。
type GameCreatorJob struct {
	DisplayName GameCreatorJobDisplayName `json:"displayName"`

	// Id ゲームクリエイターのjobのIDを表します。
	Id *GameCreatorJobID `json:"id,omitempty"`

	// IsCustomJob ユーザーが定義したカスタムjobかどうかを表します。
	IsCustomJob bool `json:"isCustomJob"`
}

// GameCreatorJobDisplayName defines model for GameCreatorJobDisplayName.
type GameCreatorJobDisplayName = string

// GameCreatorJobID ゲームクリエイターのjobのIDを表します。
type GameCreatorJobID = openapi_types.UUID

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt defines model for GameGenreCreatedAt.
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription  `json:"description"`
	Genres      *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GamePlayLogID ゲームプレイログのID(UUID)です。
type GamePlayLogID = openapi_types.UUID

// GamePlayStats ゲームのプレイ統計データです。
type GamePlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// GamePlayStatsInEdition エディション内のゲームプレイ統計データです。
type GamePlayStatsInEdition struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// PlayCount 指定期間内のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime 指定期間内のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`
}

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVersionPlayStats ゲームバージョンのプレイ統計データです。
type GameVersionPlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`

	// VersionName ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	VersionName GameVersionName `json:"versionName"`
}

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
// ゲーム作成時、指定がない場合はprivateになります
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// HourlyPlayStats 時台別のプレイ統計データです。各時台（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00から2025-01-01T14:59:59+09:00）の統計を返します。
type HourlyPlayStats struct {
	// PlayCount この時台のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime この時台のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`

	// StartTime この統計データの対象時台の開始時刻です（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00）。
	StartTime time.Time `json:"startTime"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	// ジャンルに重複があった場合は400エラーとなります。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// PatchGameCreatorsRequest defines model for PatchGameCreatorsRequest.
type PatchGameCreatorsRequest = []PatchGameCreatorsRequestItem

// PatchGameCreatorsRequestItem defines model for PatchGameCreatorsRequestItem.
type PatchGameCreatorsRequestItem struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id   UserID                                    `json:"id"`
	Jobs *[]PatchGameCreatorsRequestItem_Jobs_Item `json:"jobs,omitempty"`
}

// PatchGameCreatorsRequestItemJobs0 defines model for .
type PatchGameCreatorsRequestItemJobs0 struct {
	// Id ゲームクリエイターのjobのIDを表します。
	Id GameCreatorJobID `json:"id"`
}

// PatchGameCreatorsRequestItemJobs1 defines model for .
type PatchGameCreatorsRequestItemJobs1 struct {
	CustomDisplayName GameCreatorJobDisplayName `json:"customDisplayName"`
}

// PatchGameCreatorsRequestItem_Jobs_Item defines model for PatchGameCreatorsRequestItem.jobs.Item.
type PatchGameCreatorsRequestItem_Jobs_Item struct {
	union json.RawMessage
}

// PatchGamePlayLogEndRequest ゲーム終了ログの記録リクエストです。
type PatchGamePlayLogEndRequest struct {
	// EndTime ゲーム終了時刻です。
	EndTime time.Time `json:"endTime"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostGamePlayLogStartRequest ゲーム起動ログの記録リクエストです。
type PostGamePlayLogStartRequest struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// StartTime ゲーム起動時刻です。
	StartTime time.Time `json:"startTime"`
}

// PostGamePlayLogStartResponse ゲーム起動ログのレスポンスです。PlayLogIDを返却します。
type PostGamePlayLogStartResponse struct {
	// PlayLogID ゲームプレイログのID(UUID)です。
	PlayLogID GamePlayLogID `json:"playLogID"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVersionIDInQuery defines model for gameVersionIDInQuery.
type GameVersionIDInQuery = openapi_types.UUID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// PeriodEndInQuery defines model for periodEndInQuery.
type PeriodEndInQuery = time.Time

// PeriodStartInQuery defines model for periodStartInQuery.
type PeriodStartInQuery = time.Time

// PlayLogIDInPath defines model for playLogIDInPath.
type PlayLogIDInPath = openapi_types.UUID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetEditionPlayStatsParams defines parameters for GetEditionPlayStats.
type GetEditionPlayStatsParams struct {
	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合はすべてのゲームが取得されます。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreName `json:"genres,omitempty"`
}

// GetGamePlayStatsParams defines parameters for GetGamePlayStats.
type GetGamePlayStatsParams struct {
	// GameVersionID ゲームバージョンのIDを示すクエリパラメータです。
	// 指定した場合は特定バージョンの統計データを取得し、指定しない場合は全バージョンの統計データを取得します。
	GameVersionID *GameVersionIDInQuery `form:"gameVersionID,omitempty" json:"gameVersionID,omitempty"`

	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Bot falseの場合botを除外します。
	// デフォルトではbotも含めます。
	Bot *bool `form:"bot,omitempty" json:"bot,omitempty"`

	// IncludeSuspended trueの場合、凍結済みユーザーも含めます。
	// デフォルトでは凍結済みユーザーは含めません。
	IncludeSuspended *bool `form:"includeSuspended,omitempty" json:"includeSuspended,omitempty"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PatchEditionGameJSONRequestBody defines body for PatchEditionGame for application/json ContentType.
type PatchEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGamePlayLogStartJSONRequestBody defines body for PostGamePlayLogStart for application/json ContentType.
type PostGamePlayLogStartJSONRequestBody = PostGamePlayLogStartRequest

// PatchGamePlayLogEndJSONRequestBody defines body for PatchGamePlayLogEnd for application/json ContentType.
type PatchGamePlayLogEndJSONRequestBody = PatchGamePlayLogEndRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PatchGameCreatorsJSONRequestBody defines body for PatchGameCreators for application/json ContentType.
type PatchGameCreatorsJSONRequestBody = PatchGameCreatorsRequest

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// AsPatchGameCreatorsRequestItemJobs0 returns the union data inside the PatchGameCreatorsRequestItem_Jobs_Item as a PatchGameCreatorsRequestItemJobs0
func (t PatchGameCreatorsRequestItem_Jobs_Item) AsPatchGameCreatorsRequestItemJobs0() (PatchGameCreatorsRequestItemJobs0, error) {
	var body PatchGameCreatorsRequestItemJobs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPatchGameCreatorsRequestItemJobs0 overwrites any union data inside the PatchGameCreatorsRequestItem_Jobs_Item as the provided PatchGameCreatorsRequestItemJobs0
func (t *PatchGameCreatorsRequestItem_Jobs_Item) FromPatchGameCreatorsRequestItemJobs0(v PatchGameCreatorsRequestItemJobs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePatchGameCreatorsRequestItemJobs0 performs a merge with any union data inside the PatchGameCreatorsRequestItem_Jobs_Item, using the provided PatchGameCreatorsRequestItemJobs0
func (t *PatchGameCreatorsRequestItem_Jobs_Item) MergePatchGameCreatorsRequestItemJobs0(v PatchGameCreatorsRequestItemJobs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPatchGameCreatorsRequestItemJobs1 returns the union data inside the PatchGameCreatorsRequestItem_Jobs_Item as a PatchGameCreatorsRequestItemJobs1
func (t PatchGameCreatorsRequestItem_Jobs_Item) AsPatchGameCreatorsRequestItemJobs1() (PatchGameCreatorsRequestItemJobs1, error) {
	var body PatchGameCreatorsRequestItemJobs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPatchGameCreatorsRequestItemJobs1 overwrites any union data inside the PatchGameCreatorsRequestItem_Jobs_Item as the provided PatchGameCreatorsRequestItemJobs1
func (t *PatchGameCreatorsRequestItem_Jobs_Item) FromPatchGameCreatorsRequestItemJobs1(v PatchGameCreatorsRequestItemJobs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePatchGameCreatorsRequestItemJobs1 performs a merge with any union data inside the PatchGameCreatorsRequestItem_Jobs_Item, using the provided PatchGameCreatorsRequestItemJobs1
func (t *PatchGameCreatorsRequestItem_Jobs_Item) MergePatchGameCreatorsRequestItemJobs1(v PatchGameCreatorsRequestItemJobs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PatchGameCreatorsRequestItem_Jobs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PatchGameCreatorsRequestItem_Jobs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// ゲームクリエイターのジョブ一覧の取得
	// (GET /creators/jobs)
	GetGameCreatorJobs(ctx echo.Context) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PatchEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// ゲーム起動ログの記録
	// (POST /editions/{editionID}/games/{gameID}/plays/start)
	PostGamePlayLogStart(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath) error

	// (DELETE /editions/{editionID}/games/{gameID}/plays/{playLogID})
	DeleteGamePlayLog(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// ゲーム終了ログの記録
	// (PATCH /editions/{editionID}/games/{gameID}/plays/{playLogID}/end)
	PatchGamePlayLogEnd(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// エディションのプレイ統計取得
	// (GET /editions/{editionID}/play-stats)
	GetEditionPlayStats(ctx echo.Context, editionID EditionIDInPath, params GetEditionPlayStatsParams) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイター一覧の取得
	// (GET /games/{gameID}/creators)
	GetGameCreators(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイター一覧の更新
	// (PATCH /games/{gameID}/creators)
	PatchGameCreators(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイターの削除
	// (DELETE /games/{gameID}/creators/{userID})
	DeleteGameCreator(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームのプレイ統計取得
	// (GET /games/{gameID}/play-stats)
	GetGamePlayStats(ctx echo.Context, gameID GameIDInPath, params GetGamePlayStatsParams) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetGameCreatorJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameCreatorJobs(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameCreatorJobs(ctx)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PatchEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEditionGame(ctx, editionID)
	return err
}

// PostGamePlayLogStart converts echo context to params.
func (w *ServerInterfaceWrapper) PostGamePlayLogStart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGamePlayLogStart(ctx, editionID, gameID)
	return err
}

// DeleteGamePlayLog converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGamePlayLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGamePlayLog(ctx, editionID, gameID, playLogID)
	return err
}

// PatchGamePlayLogEnd converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGamePlayLogEnd(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGamePlayLogEnd(ctx, editionID, gameID, playLogID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetEditionPlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionPlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEditionPlayStatsParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionPlayStats(ctx, editionID, params)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameCreators converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameCreators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameCreatorsVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameCreators(ctx, gameID)
	return err
}

// PatchGameCreators converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameCreators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameCreators(ctx, gameID)
	return err
}

// DeleteGameCreator converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameCreator(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameCreator(ctx, gameID, userID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// GetGamePlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetGamePlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamePlayStatsParams
	// ------------- Optional query parameter "gameVersionID" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameVersionID", ctx.QueryParams(), &params.GameVersionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVersionID: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGamePlayStats(ctx, gameID, params)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "bot" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot", ctx.QueryParams(), &params.Bot)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bot: %s", err))
	}

	// ------------- Optional query parameter "includeSuspended" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeSuspended", ctx.QueryParams(), &params.IncludeSuspended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeSuspended: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/creators/jobs", wrapper.GetGameCreatorJobs)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PatchEditionGame)
	router.POST(baseURL+"/editions/:editionID/games/:gameID/plays/start", wrapper.PostGamePlayLogStart)
	router.DELETE(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID", wrapper.DeleteGamePlayLog)
	router.PATCH(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID/end", wrapper.PatchGamePlayLogEnd)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/editions/:editionID/play-stats", wrapper.GetEditionPlayStats)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/creators", wrapper.GetGameCreators)
	router.PATCH(baseURL+"/games/:gameID/creators", wrapper.PatchGameCreators)
	router.DELETE(baseURL+"/games/:gameID/creators/:userID", wrapper.DeleteGameCreator)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.GET(baseURL+"/games/:gameID/play-stats", wrapper.GetGamePlayStats)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"etzDaVGQwb11cuL/BwAA//+zhuAQmbIBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
