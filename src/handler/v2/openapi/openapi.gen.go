// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes                  = "AdminAuth.Scopes"
	EditionAuthScopes                = "EditionAuth.Scopes"
	EditionGameFileAuthScopes        = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes       = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes       = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes              = "EditionIDAuth.Scopes"
	GameCreatorsVisibilityAuthScopes = "GameCreatorsVisibilityAuth.Scopes"
	GameFileVisibilityAuthScopes     = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes    = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes     = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes         = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes              = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes    = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes             = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videom4v GameVideoMime = "video/m4v"
	Videomkv GameVideoMime = "video/mkv"
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionPlayStats エディションのプレイ統計データです。
type EditionPlayStats struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// EditionName エディション名です。
	EditionName EditionName `json:"editionName"`

	// GameStats エディションに含まれるゲームごとの統計データです。
	GameStats []GamePlayStatsInEdition `json:"gameStats"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// FeedbackAnswer defines model for FeedbackAnswer.
type FeedbackAnswer struct {
	// Answer Yes=true, No=false
	Answer bool `json:"answer"`

	// QuestionID フィードバック質問ID
	QuestionID FeedbackQuestionID `json:"questionID"`

	// QuestionText 質問文
	QuestionText string `json:"questionText"`
}

// FeedbackAnswerInput defines model for FeedbackAnswerInput.
type FeedbackAnswerInput struct {
	// Answer Yes=true, No=false
	Answer bool `json:"answer"`

	// QuestionID フィードバック質問ID
	QuestionID FeedbackQuestionID `json:"questionID"`
}

// FeedbackDetail defines model for FeedbackDetail.
type FeedbackDetail struct {
	Answers []FeedbackAnswer `json:"answers"`

	// Comment 自由記述コメント
	Comment   *string   `json:"comment"`
	CreatedAt time.Time `json:"createdAt"`

	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// EditionName エディション名です。
	EditionName EditionName `json:"editionName"`

	// Id ゲームフィードバックID
	Id GameFeedbackID `json:"id"`
}

// FeedbackQuestion defines model for FeedbackQuestion.
type FeedbackQuestion struct {
	// Id フィードバック質問ID
	Id FeedbackQuestionID `json:"id"`

	// QuestionOrder 表示順序
	QuestionOrder int `json:"questionOrder"`

	// QuestionText 質問文
	QuestionText string `json:"questionText"`
}

// FeedbackQuestionID フィードバック質問ID
type FeedbackQuestionID = openapi_types.UUID

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameCreator defines model for GameCreator.
type GameCreator struct {
	Jobs []GameCreatorJob `json:"jobs"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// GameCreatorJob ゲームクリエイターのjob情報を表します。
type GameCreatorJob struct {
	DisplayName GameCreatorJobDisplayName `json:"displayName"`

	// Id ゲームクリエイターのjobのIDを表します。
	Id GameCreatorJobID `json:"id"`

	// IsCustomJob ユーザーが定義したカスタムjobかどうかを表します。
	IsCustomJob bool `json:"isCustomJob"`
}

// GameCreatorJobDisplayName defines model for GameCreatorJobDisplayName.
type GameCreatorJobDisplayName = string

// GameCreatorJobID ゲームクリエイターのjobのIDを表します。
type GameCreatorJobID = openapi_types.UUID

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFeedback defines model for GameFeedback.
type GameFeedback struct {
	CreatedAt time.Time `json:"createdAt"`

	// Id ゲームフィードバックID
	Id GameFeedbackID `json:"id"`
}

// GameFeedbackDetail ゲームバージョン情報を含むフィードバック詳細
type GameFeedbackDetail struct {
	Answers []FeedbackAnswer `json:"answers"`

	// Comment 自由記述コメント
	Comment   *string   `json:"comment"`
	CreatedAt time.Time `json:"createdAt"`

	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// EditionName エディション名です。
	EditionName EditionName `json:"editionName"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// GameVersionName ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	GameVersionName GameVersionName `json:"gameVersionName"`

	// Id ゲームフィードバックID
	Id GameFeedbackID `json:"id"`
}

// GameFeedbackID ゲームフィードバックID
type GameFeedbackID = openapi_types.UUID

// GameFeedbacksResponse ゲーム全体のフィードバック一覧（バージョン情報付き）
type GameFeedbacksResponse struct {
	Feedbacks []GameFeedbackDetail `json:"feedbacks"`

	// Total フィードバックの総数
	Total int `json:"total"`
}

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt defines model for GameGenreCreatedAt.
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription  `json:"description"`
	Genres      *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GamePlayLogID ゲームプレイログのID(UUID)です。
type GamePlayLogID = openapi_types.UUID

// GamePlayStats ゲームのプレイ統計データです。
type GamePlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// GamePlayStatsInEdition エディション内のゲームプレイ統計データです。
type GamePlayStatsInEdition struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// PlayCount 指定期間内のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime 指定期間内のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`
}

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFeedbacksResponse 特定バージョンのフィードバック一覧
type GameVersionFeedbacksResponse struct {
	Feedbacks []FeedbackDetail `json:"feedbacks"`

	// Total フィードバックの総数
	Total int `json:"total"`
}

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVersionPlayStats ゲームバージョンのプレイ統計データです。
type GameVersionPlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`

	// VersionName ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	VersionName GameVersionName `json:"versionName"`
}

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
// ゲーム作成時、指定がない場合はprivateになります
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// HourlyPlayStats 時台別のプレイ統計データです。各時台（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00から2025-01-01T14:59:59+09:00）の統計を返します。
type HourlyPlayStats struct {
	// PlayCount この時台のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime この時台のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`

	// StartTime この統計データの対象時台の開始時刻です（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00）。
	StartTime time.Time `json:"startTime"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	// ジャンルに重複があった場合は400エラーとなります。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// PatchGamePlayLogEndRequest ゲーム終了ログの記録リクエストです。
type PatchGamePlayLogEndRequest struct {
	// EndTime ゲーム終了時刻です。
	EndTime time.Time `json:"endTime"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostGameFeedbackRequest defines model for PostGameFeedbackRequest.
type PostGameFeedbackRequest struct {
	// Answers 質問に対するYes/No回答の配列
	Answers []FeedbackAnswerInput `json:"answers"`

	// Comment 自由記述コメント（任意）
	Comment *string `json:"comment,omitempty"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`
}

// PostGamePlayLogStartRequest ゲーム起動ログの記録リクエストです。
type PostGamePlayLogStartRequest struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// StartTime ゲーム起動時刻です。
	StartTime time.Time `json:"startTime"`
}

// PostGamePlayLogStartResponse ゲーム起動ログのレスポンスです。PlayLogIDを返却します。
type PostGamePlayLogStartResponse struct {
	// PlayLogID ゲームプレイログのID(UUID)です。
	PlayLogID GamePlayLogID `json:"playLogID"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// PutGameCreatorsRequest defines model for PutGameCreatorsRequest.
type PutGameCreatorsRequest = []PutGameCreatorsRequestItem

// PutGameCreatorsRequestItem defines model for PutGameCreatorsRequestItem.
type PutGameCreatorsRequestItem struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Jobs ゲームクリエイターのjob情報の配列です。
	// 配列の各要素は、既存のjob（プリセットのjob+ゲームにすでにあるjob)のIDを指定するか、
	// 新しいカスタムjobの表示名を指定します。
	// 既存のjobのIDは重複してはいけません。
	// 新しいカスタムjobの表示名は、既にあるカスタムjobの表示名と重複してはいけません。
	Jobs *[]PutGameCreatorsRequestItem_Jobs_Item `json:"jobs,omitempty"`
}

// PutGameCreatorsRequestItemJobs0 既存のゲームクリエイターのjobのIDを指定します。
type PutGameCreatorsRequestItemJobs0 struct {
	// Id ゲームクリエイターのjobのIDを表します。
	Id GameCreatorJobID `json:"id"`
}

// PutGameCreatorsRequestItemJobs1 新しいカスタムjobの表示名を指定します。
type PutGameCreatorsRequestItemJobs1 struct {
	CustomDisplayName GameCreatorJobDisplayName `json:"customDisplayName"`
}

// PutGameCreatorsRequestItem_Jobs_Item defines model for PutGameCreatorsRequestItem.jobs.Item.
type PutGameCreatorsRequestItem_Jobs_Item struct {
	union json.RawMessage
}

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVersionIDInPath defines model for gameVersionIDInPath.
type GameVersionIDInPath = openapi_types.UUID

// GameVersionIDInQuery defines model for gameVersionIDInQuery.
type GameVersionIDInQuery = openapi_types.UUID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// PeriodEndInQuery defines model for periodEndInQuery.
type PeriodEndInQuery = time.Time

// PeriodStartInQuery defines model for periodStartInQuery.
type PeriodStartInQuery = time.Time

// PlayLogIDInPath defines model for playLogIDInPath.
type PlayLogIDInPath = openapi_types.UUID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetEditionPlayStatsParams defines parameters for GetEditionPlayStats.
type GetEditionPlayStatsParams struct {
	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合はすべてのゲームが取得されます。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// GetGameFeedbacksParams defines parameters for GetGameFeedbacks.
type GetGameFeedbacksParams struct {
	// Limit 取得するフィードバックの最大数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得開始位置のオフセット
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreName `json:"genres,omitempty"`
}

// GetGamePlayStatsParams defines parameters for GetGamePlayStats.
type GetGamePlayStatsParams struct {
	// GameVersionID ゲームバージョンのIDを示すクエリパラメータです。
	// 指定した場合は特定バージョンの統計データを取得し、指定しない場合は全バージョンの統計データを取得します。
	GameVersionID *GameVersionIDInQuery `form:"gameVersionID,omitempty" json:"gameVersionID,omitempty"`

	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetGameVersionFeedbacksParams defines parameters for GetGameVersionFeedbacks.
type GetGameVersionFeedbacksParams struct {
	// Limit 取得するフィードバックの最大数
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得開始位置のオフセット
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Bot falseの場合botを除外します。
	// デフォルトではbotも含めます。
	Bot *bool `form:"bot,omitempty" json:"bot,omitempty"`

	// IncludeSuspended trueの場合、凍結済みユーザーも含めます。
	// デフォルトでは凍結済みユーザーは含めません。
	IncludeSuspended *bool `form:"includeSuspended,omitempty" json:"includeSuspended,omitempty"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PatchEditionGameJSONRequestBody defines body for PatchEditionGame for application/json ContentType.
type PatchEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGameFeedbackJSONRequestBody defines body for PostGameFeedback for application/json ContentType.
type PostGameFeedbackJSONRequestBody = PostGameFeedbackRequest

// PostGamePlayLogStartJSONRequestBody defines body for PostGamePlayLogStart for application/json ContentType.
type PostGamePlayLogStartJSONRequestBody = PostGamePlayLogStartRequest

// PatchGamePlayLogEndJSONRequestBody defines body for PatchGamePlayLogEnd for application/json ContentType.
type PatchGamePlayLogEndJSONRequestBody = PatchGamePlayLogEndRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PutGameCreatorsJSONRequestBody defines body for PutGameCreators for application/json ContentType.
type PutGameCreatorsJSONRequestBody = PutGameCreatorsRequest

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// AsPutGameCreatorsRequestItemJobs0 returns the union data inside the PutGameCreatorsRequestItem_Jobs_Item as a PutGameCreatorsRequestItemJobs0
func (t PutGameCreatorsRequestItem_Jobs_Item) AsPutGameCreatorsRequestItemJobs0() (PutGameCreatorsRequestItemJobs0, error) {
	var body PutGameCreatorsRequestItemJobs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPutGameCreatorsRequestItemJobs0 overwrites any union data inside the PutGameCreatorsRequestItem_Jobs_Item as the provided PutGameCreatorsRequestItemJobs0
func (t *PutGameCreatorsRequestItem_Jobs_Item) FromPutGameCreatorsRequestItemJobs0(v PutGameCreatorsRequestItemJobs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePutGameCreatorsRequestItemJobs0 performs a merge with any union data inside the PutGameCreatorsRequestItem_Jobs_Item, using the provided PutGameCreatorsRequestItemJobs0
func (t *PutGameCreatorsRequestItem_Jobs_Item) MergePutGameCreatorsRequestItemJobs0(v PutGameCreatorsRequestItemJobs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPutGameCreatorsRequestItemJobs1 returns the union data inside the PutGameCreatorsRequestItem_Jobs_Item as a PutGameCreatorsRequestItemJobs1
func (t PutGameCreatorsRequestItem_Jobs_Item) AsPutGameCreatorsRequestItemJobs1() (PutGameCreatorsRequestItemJobs1, error) {
	var body PutGameCreatorsRequestItemJobs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPutGameCreatorsRequestItemJobs1 overwrites any union data inside the PutGameCreatorsRequestItem_Jobs_Item as the provided PutGameCreatorsRequestItemJobs1
func (t *PutGameCreatorsRequestItem_Jobs_Item) FromPutGameCreatorsRequestItemJobs1(v PutGameCreatorsRequestItemJobs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePutGameCreatorsRequestItemJobs1 performs a merge with any union data inside the PutGameCreatorsRequestItem_Jobs_Item, using the provided PutGameCreatorsRequestItemJobs1
func (t *PutGameCreatorsRequestItem_Jobs_Item) MergePutGameCreatorsRequestItemJobs1(v PutGameCreatorsRequestItemJobs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PutGameCreatorsRequestItem_Jobs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PutGameCreatorsRequestItem_Jobs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PatchEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// ゲームフィードバックの送信
	// (POST /editions/{editionID}/games/{gameID}/feedbacks)
	PostGameFeedback(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath) error
	// ゲーム起動ログの記録
	// (POST /editions/{editionID}/games/{gameID}/plays/start)
	PostGamePlayLogStart(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath) error

	// (DELETE /editions/{editionID}/games/{gameID}/plays/{playLogID})
	DeleteGamePlayLog(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// ゲーム終了ログの記録
	// (PATCH /editions/{editionID}/games/{gameID}/plays/{playLogID}/end)
	PatchGamePlayLogEnd(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// エディションのプレイ統計取得
	// (GET /editions/{editionID}/play-stats)
	GetEditionPlayStats(ctx echo.Context, editionID EditionIDInPath, params GetEditionPlayStatsParams) error
	// フィードバック質問一覧の取得
	// (GET /feedbacks/questions)
	GetFeedbackQuestions(ctx echo.Context) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイター一覧の取得
	// (GET /games/{gameID}/creators)
	GetGameCreators(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイター一覧の更新
	// (PUT /games/{gameID}/creators)
	PutGameCreators(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイターのジョブ一覧の取得
	// (GET /games/{gameID}/creators/jobs)
	GetGameCreatorJobs(ctx echo.Context, gameID GameIDInPath) error
	// ゲームのフィードバック一覧取得
	// (GET /games/{gameID}/feedbacks)
	GetGameFeedbacks(ctx echo.Context, gameID GameIDInPath, params GetGameFeedbacksParams) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームのプレイ統計取得
	// (GET /games/{gameID}/play-stats)
	GetGamePlayStats(ctx echo.Context, gameID GameIDInPath, params GetGamePlayStatsParams) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームバージョンのフィードバック一覧取得
	// (GET /games/{gameID}/versions/{gameVersionID}/feedbacks)
	GetGameVersionFeedbacks(ctx echo.Context, gameID GameIDInPath, gameVersionID GameVersionIDInPath, params GetGameVersionFeedbacksParams) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PatchEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEditionGame(ctx, editionID)
	return err
}

// PostGameFeedback converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFeedback(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFeedback(ctx, editionID, gameID)
	return err
}

// PostGamePlayLogStart converts echo context to params.
func (w *ServerInterfaceWrapper) PostGamePlayLogStart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGamePlayLogStart(ctx, editionID, gameID)
	return err
}

// DeleteGamePlayLog converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGamePlayLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGamePlayLog(ctx, editionID, gameID, playLogID)
	return err
}

// PatchGamePlayLogEnd converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGamePlayLogEnd(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGamePlayLogEnd(ctx, editionID, gameID, playLogID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetEditionPlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionPlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEditionPlayStatsParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionPlayStats(ctx, editionID, params)
	return err
}

// GetFeedbackQuestions converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeedbackQuestions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeedbackQuestions(ctx)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameCreators converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameCreators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameCreatorsVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameCreators(ctx, gameID)
	return err
}

// PutGameCreators converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameCreators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameCreators(ctx, gameID)
	return err
}

// GetGameCreatorJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameCreatorJobs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameCreatorJobs(ctx, gameID)
	return err
}

// GetGameFeedbacks converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFeedbacks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameFeedbacksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFeedbacks(ctx, gameID, params)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// GetGamePlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetGamePlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamePlayStatsParams
	// ------------- Optional query parameter "gameVersionID" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameVersionID", ctx.QueryParams(), &params.GameVersionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVersionID: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGamePlayStats(ctx, gameID, params)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVersionFeedbacks converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersionFeedbacks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVersionID" -------------
	var gameVersionID GameVersionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVersionID", ctx.Param("gameVersionID"), &gameVersionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVersionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionFeedbacksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersionFeedbacks(ctx, gameID, gameVersionID, params)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "bot" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot", ctx.QueryParams(), &params.Bot)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bot: %s", err))
	}

	// ------------- Optional query parameter "includeSuspended" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeSuspended", ctx.QueryParams(), &params.IncludeSuspended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeSuspended: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PatchEditionGame)
	router.POST(baseURL+"/editions/:editionID/games/:gameID/feedbacks", wrapper.PostGameFeedback)
	router.POST(baseURL+"/editions/:editionID/games/:gameID/plays/start", wrapper.PostGamePlayLogStart)
	router.DELETE(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID", wrapper.DeleteGamePlayLog)
	router.PATCH(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID/end", wrapper.PatchGamePlayLogEnd)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/editions/:editionID/play-stats", wrapper.GetEditionPlayStats)
	router.GET(baseURL+"/feedbacks/questions", wrapper.GetFeedbackQuestions)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/creators", wrapper.GetGameCreators)
	router.PUT(baseURL+"/games/:gameID/creators", wrapper.PutGameCreators)
	router.GET(baseURL+"/games/:gameID/creators/jobs", wrapper.GetGameCreatorJobs)
	router.GET(baseURL+"/games/:gameID/feedbacks", wrapper.GetGameFeedbacks)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.GET(baseURL+"/games/:gameID/play-stats", wrapper.GetGamePlayStats)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/:gameVersionID/feedbacks", wrapper.GetGameVersionFeedbacks)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
