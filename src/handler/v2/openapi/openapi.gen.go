// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes          = "AdminAuth.Scopes"
	EditionAuthScopes        = "EditionAuth.Scopes"
	EditionIDAuthScopes      = "EditionIDAuth.Scopes"
	GameMaintainerAuthScopes = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes      = "GameOwnerAuth.Scopes"
	TrapMemberAuthScopes     = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres []GameGenreName `json:"genres"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	// CreatedAt ジャンルが作成された日時です
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt ジャンルが作成された日時です
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`
	Genres      []GameGenreID   `json:"genres"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// GameName ゲームの名前です。
type GameName = string

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合は30です。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreID `json:"genres,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PostEditionGameJSONRequestBody defines body for PostEditionGame for application/json ContentType.
type PostEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PostEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PostEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionGame(ctx, editionID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "productKeyID", runtime.ParamLocationPath, ctx.Param("productKeyID"), &productKeyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "productKeyID", runtime.ParamLocationPath, ctx.Param("productKeyID"), &productKeyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameFileID", runtime.ParamLocationPath, ctx.Param("gameFileID"), &gameFileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameFileID", runtime.ParamLocationPath, ctx.Param("gameFileID"), &gameFileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameImageID", runtime.ParamLocationPath, ctx.Param("gameImageID"), &gameImageID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameImageID", runtime.ParamLocationPath, ctx.Param("gameImageID"), &gameImageID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameVideoID", runtime.ParamLocationPath, ctx.Param("gameVideoID"), &gameVideoID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameVideoID", runtime.ParamLocationPath, ctx.Param("gameVideoID"), &gameVideoID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameGenreID", runtime.ParamLocationPath, ctx.Param("gameGenreID"), &gameGenreID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameGenreID", runtime.ParamLocationPath, ctx.Param("gameGenreID"), &gameGenreID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "seatID", runtime.ParamLocationPath, ctx.Param("seatID"), &seatID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PostEditionGame)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Tk/8/wAAAP//SG1ZxWZPAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
