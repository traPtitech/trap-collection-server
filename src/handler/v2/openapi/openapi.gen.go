// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes          = "AdminAuth.Scopes"
	EditionAuthScopes        = "EditionAuth.Scopes"
	EditionIDAuthScopes      = "EditionIDAuth.Scopes"
	GameMaintainerAuthScopes = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes      = "GameOwnerAuth.Scopes"
	TrapMemberAuthScopes     = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres []GameGenreName `json:"genres"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	// CreatedAt ジャンルが作成された日時です
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt ジャンルが作成された日時です
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`
	Genres      []GameGenreID   `json:"genres"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// GameName ゲームの名前です。
type GameName = string

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合は30です。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreID `json:"genres,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PostEditionGameJSONRequestBody defines body for PostEditionGame for application/json ContentType.
type PostEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PostEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PostEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionGame(ctx, editionID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PostEditionGame)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"VwlzN/wOKGDjJ8f/fwAAAP//6rU1TjRPAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
