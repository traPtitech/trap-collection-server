// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes               = "AdminAuth.Scopes"
	EditionAuthScopes             = "EditionAuth.Scopes"
	EditionGameFileAuthScopes     = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes    = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes    = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes           = "EditionIDAuth.Scopes"
	GameFileVisibilityAuthScopes  = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes  = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes      = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes           = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes          = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videom4v GameVideoMime = "video/m4v"
	Videomkv GameVideoMime = "video/mkv"
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionPlayStats エディションのプレイ統計データです。
type EditionPlayStats struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// EditionName エディション名です。
	EditionName EditionName `json:"editionName"`

	// GameStats エディションに含まれるゲームごとの統計データです。
	GameStats []GamePlayStatsInEdition `json:"gameStats"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt defines model for GameGenreCreatedAt.
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription  `json:"description"`
	Genres      *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GamePlayLogID ゲームプレイログのID(UUID)です。
type GamePlayLogID = openapi_types.UUID

// GamePlayStats ゲームのプレイ統計データです。
type GamePlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// GamePlayStatsInEdition エディション内のゲームプレイ統計データです。
type GamePlayStatsInEdition struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// PlayCount 指定期間内のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime 指定期間内のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`
}

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVersionPlayStats ゲームバージョンのプレイ統計データです。
type GameVersionPlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`

	// VersionName ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	VersionName GameVersionName `json:"versionName"`
}

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
// ゲーム作成時、指定がない場合はprivateになります
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// HourlyPlayStats 時台別のプレイ統計データです。各時台（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00から2025-01-01T14:59:59+09:00）の統計を返します。
type HourlyPlayStats struct {
	// PlayCount この時台のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime この時台のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`

	// StartTime この統計データの対象時台の開始時刻です（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00）。
	StartTime time.Time `json:"startTime"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	// ジャンルに重複があった場合は400エラーとなります。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// PatchGamePlayLogEndRequest ゲーム終了ログの記録リクエストです。
type PatchGamePlayLogEndRequest struct {
	// EndTime ゲーム終了時刻です。
	EndTime time.Time `json:"endTime"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostGamePlayLogStartRequest ゲーム起動ログの記録リクエストです。
type PostGamePlayLogStartRequest struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// StartTime ゲーム起動時刻です。
	StartTime time.Time `json:"startTime"`
}

// PostGamePlayLogStartResponse ゲーム起動ログのレスポンスです。PlayLogIDを返却します。
type PostGamePlayLogStartResponse struct {
	// PlayLogID ゲームプレイログのID(UUID)です。
	PlayLogID GamePlayLogID `json:"playLogID"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVersionIDInQuery defines model for gameVersionIDInQuery.
type GameVersionIDInQuery = openapi_types.UUID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// PeriodEndInQuery defines model for periodEndInQuery.
type PeriodEndInQuery = time.Time

// PeriodStartInQuery defines model for periodStartInQuery.
type PeriodStartInQuery = time.Time

// PlayLogIDInPath defines model for playLogIDInPath.
type PlayLogIDInPath = openapi_types.UUID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetEditionPlayStatsParams defines parameters for GetEditionPlayStats.
type GetEditionPlayStatsParams struct {
	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合はすべてのゲームが取得されます。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreName `json:"genres,omitempty"`
}

// GetGamePlayStatsParams defines parameters for GetGamePlayStats.
type GetGamePlayStatsParams struct {
	// GameVersionID ゲームバージョンのIDを示すクエリパラメータです。
	// 指定した場合は特定バージョンの統計データを取得し、指定しない場合は全バージョンの統計データを取得します。
	GameVersionID *GameVersionIDInQuery `form:"gameVersionID,omitempty" json:"gameVersionID,omitempty"`

	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Bot falseの場合botを除外します。
	// デフォルトではbotも含めます。
	Bot *bool `form:"bot,omitempty" json:"bot,omitempty"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PatchEditionGameJSONRequestBody defines body for PatchEditionGame for application/json ContentType.
type PatchEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGamePlayLogStartJSONRequestBody defines body for PostGamePlayLogStart for application/json ContentType.
type PostGamePlayLogStartJSONRequestBody = PostGamePlayLogStartRequest

// PatchGamePlayLogEndJSONRequestBody defines body for PatchGamePlayLogEnd for application/json ContentType.
type PatchGamePlayLogEndJSONRequestBody = PatchGamePlayLogEndRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PatchEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// ゲーム起動ログの記録
	// (POST /editions/{editionID}/games/{gameID}/plays/start)
	PostGamePlayLogStart(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath) error

	// (DELETE /editions/{editionID}/games/{gameID}/plays/{playLogID})
	DeleteGamePlayLog(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// ゲーム終了ログの記録
	// (PATCH /editions/{editionID}/games/{gameID}/plays/{playLogID}/end)
	PatchGamePlayLogEnd(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// エディションのプレイ統計取得
	// (GET /editions/{editionID}/play-stats)
	GetEditionPlayStats(ctx echo.Context, editionID EditionIDInPath, params GetEditionPlayStatsParams) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームのプレイ統計取得
	// (GET /games/{gameID}/play-stats)
	GetGamePlayStats(ctx echo.Context, gameID GameIDInPath, params GetGamePlayStatsParams) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PatchEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEditionGame(ctx, editionID)
	return err
}

// PostGamePlayLogStart converts echo context to params.
func (w *ServerInterfaceWrapper) PostGamePlayLogStart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGamePlayLogStart(ctx, editionID, gameID)
	return err
}

// DeleteGamePlayLog converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGamePlayLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGamePlayLog(ctx, editionID, gameID, playLogID)
	return err
}

// PatchGamePlayLogEnd converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGamePlayLogEnd(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGamePlayLogEnd(ctx, editionID, gameID, playLogID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetEditionPlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionPlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEditionPlayStatsParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionPlayStats(ctx, editionID, params)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// GetGamePlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetGamePlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamePlayStatsParams
	// ------------- Optional query parameter "gameVersionID" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameVersionID", ctx.QueryParams(), &params.GameVersionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVersionID: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGamePlayStats(ctx, gameID, params)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "bot" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot", ctx.QueryParams(), &params.Bot)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bot: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PatchEditionGame)
	router.POST(baseURL+"/editions/:editionID/games/:gameID/plays/start", wrapper.PostGamePlayLogStart)
	router.DELETE(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID", wrapper.DeleteGamePlayLog)
	router.PATCH(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID/end", wrapper.PatchGamePlayLogEnd)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/editions/:editionID/play-stats", wrapper.GetEditionPlayStats)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.GET(baseURL+"/games/:gameID/play-stats", wrapper.GetGamePlayStats)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
