// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes               = "AdminAuth.Scopes"
	EditionAuthScopes             = "EditionAuth.Scopes"
	EditionGameFileAuthScopes     = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes    = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes    = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes           = "EditionIDAuth.Scopes"
	GameFileVisibilityAuthScopes  = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes  = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes      = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes           = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes          = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres []GameGenreName `json:"genres"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	// CreatedAt ジャンルが作成された日時です
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt ジャンルが作成された日時です
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`
	Genres      []GameGenreID   `json:"genres"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合は30です。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreID `json:"genres,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PostEditionGameJSONRequestBody defines body for PostEditionGame for application/json ContentType.
type PostEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PostEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PostEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionGame(ctx, editionID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "productKeyID", runtime.ParamLocationPath, ctx.Param("productKeyID"), &productKeyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "productKeyID", runtime.ParamLocationPath, ctx.Param("productKeyID"), &productKeyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameFileID", runtime.ParamLocationPath, ctx.Param("gameFileID"), &gameFileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameFileID", runtime.ParamLocationPath, ctx.Param("gameFileID"), &gameFileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameImageID", runtime.ParamLocationPath, ctx.Param("gameImageID"), &gameImageID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameImageID", runtime.ParamLocationPath, ctx.Param("gameImageID"), &gameImageID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameVideoID", runtime.ParamLocationPath, ctx.Param("gameVideoID"), &gameVideoID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameVideoID", runtime.ParamLocationPath, ctx.Param("gameVideoID"), &gameVideoID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameGenreID", runtime.ParamLocationPath, ctx.Param("gameGenreID"), &gameGenreID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameGenreID", runtime.ParamLocationPath, ctx.Param("gameGenreID"), &gameGenreID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "seatID", runtime.ParamLocationPath, ctx.Param("seatID"), &seatID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PostEditionGame)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"IcjddBxQwCZPTP7/AAAA///lJZWp/1oBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
