// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes               = "AdminAuth.Scopes"
	EditionAuthScopes             = "EditionAuth.Scopes"
	EditionGameFileAuthScopes     = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes    = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes    = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes           = "EditionIDAuth.Scopes"
	GameFileVisibilityAuthScopes  = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes  = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes      = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes           = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes          = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videom4v GameVideoMime = "video/m4v"
	Videomkv GameVideoMime = "video/mkv"
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// DailyPlayStats 日別のプレイ統計データです。
type DailyPlayStats struct {
	// Date 日付です。YYYY-MM-DD形式です。
	Date openapi_types.Date `json:"date"`

	// PlayCount その日のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime その日のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`
}

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionPlayStats エディションのプレイ統計データです。
type EditionPlayStats struct {
	// DailyStats 日別の統計データです。
	DailyStats []DailyPlayStats `json:"dailyStats"`

	// EditionID エディションのID(UUID)です。
	EditionID openapi_types.UUID `json:"editionID"`

	// EditionName エディション名です。
	EditionName string `json:"editionName"`

	// GameStats エディションに含まれるゲームごとの統計データです。
	GameStats []GamePlayStatsInEdition `json:"gameStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlayTime 指定期間内の総プレイ時間（秒）です。
	TotalPlayTime int `json:"totalPlayTime"`
}

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt defines model for GameGenreCreatedAt.
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription  `json:"description"`
	Genres      *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GamePlayLogID ゲームプレイログのID(UUID)です。
type GamePlayLogID = openapi_types.UUID

// GamePlayStats ゲームのプレイ統計データです。
type GamePlayStats struct {
	// DailyStats 日別の統計データです。
	DailyStats []DailyPlayStats `json:"dailyStats"`

	// GameID ゲームのID(UUID)です。
	GameID openapi_types.UUID `json:"gameID"`

	// GameName ゲーム名です。
	GameName string `json:"gameName"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlayTime 指定期間内の総プレイ時間（秒）です。
	TotalPlayTime int `json:"totalPlayTime"`
}

// GamePlayStatsInEdition エディション内のゲームプレイ統計データです。
type GamePlayStatsInEdition struct {
	// GameID ゲームのID(UUID)です。
	GameID openapi_types.UUID `json:"gameID"`

	// GameName ゲーム名です。
	GameName string `json:"gameName"`

	// PlayCount 指定期間内のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime 指定期間内のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`
}

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVersionPlayStats ゲームバージョンのプレイ統計データです。
type GameVersionPlayStats struct {
	// DailyStats 日別の統計データです。
	DailyStats []DailyPlayStats `json:"dailyStats"`

	// GameID ゲームのID(UUID)です。
	GameID openapi_types.UUID `json:"gameID"`

	// GameName ゲーム名です。
	GameName string `json:"gameName"`

	// GameVersionID ゲームバージョンのID(UUID)です。
	GameVersionID openapi_types.UUID `json:"gameVersionID"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlayTime 指定期間内の総プレイ時間（秒）です。
	TotalPlayTime int `json:"totalPlayTime"`

	// VersionName バージョン名です。
	VersionName string `json:"versionName"`
}

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
// ゲーム作成時、指定がない場合はprivateになります
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	// ジャンルに重複があった場合は400エラーとなります。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// PatchGamePlayLogEndRequest ゲーム終了ログの記録リクエストです。
type PatchGamePlayLogEndRequest struct {
	// EndTime ゲーム終了時刻です。
	EndTime time.Time `json:"endTime"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostGamePlayLogStartRequest ゲーム起動ログの記録リクエストです。
type PostGamePlayLogStartRequest struct {
	// EditionID エディションのID(UUID)です。
	EditionID openapi_types.UUID `json:"editionID"`

	// GameID ゲームのID(UUID)です。
	GameID openapi_types.UUID `json:"gameID"`

	// GameVersionID ゲームバージョンのID(UUID)です。
	GameVersionID openapi_types.UUID `json:"gameVersionID"`

	// StartTime ゲーム起動時刻です。
	StartTime time.Time `json:"startTime"`
}

// PostGamePlayLogStartResponse ゲーム起動ログのレスポンスです。PlayLogIDを返却します。
type PostGamePlayLogStartResponse struct {
	// PlayLogID ゲームプレイログのID(UUID)です。
	PlayLogID GamePlayLogID `json:"playLogID"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVersionIDInQuery defines model for gameVersionIDInQuery.
type GameVersionIDInQuery = openapi_types.UUID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// PeriodEndInQuery defines model for periodEndInQuery.
type PeriodEndInQuery = time.Time

// PeriodStartInQuery defines model for periodStartInQuery.
type PeriodStartInQuery = time.Time

// PlayLogIDInPath defines model for playLogIDInPath.
type PlayLogIDInPath = openapi_types.UUID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetEditionPlayStatsParams defines parameters for GetEditionPlayStats.
type GetEditionPlayStatsParams struct {
	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// 指定がない場合は制限なしになります。
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// 指定がない場合は制限なしになります。
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合はすべてのゲームが取得されます。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreName `json:"genres,omitempty"`
}

// GetGamePlayStatsParams defines parameters for GetGamePlayStats.
type GetGamePlayStatsParams struct {
	// GameVersionID ゲームバージョンのIDを示すクエリパラメータです。
	// 指定した場合は特定バージョンの統計データを取得し、指定しない場合は全バージョンの統計データを取得します。
	GameVersionID *GameVersionIDInQuery `form:"gameVersionID,omitempty" json:"gameVersionID,omitempty"`

	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// 指定がない場合は制限なしになります。
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// 指定がない場合は制限なしになります。
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Bot falseの場合botを除外します。
	// デフォルトではbotも含めます。
	Bot *bool `form:"bot,omitempty" json:"bot,omitempty"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PatchEditionGameJSONRequestBody defines body for PatchEditionGame for application/json ContentType.
type PatchEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGamePlayLogStartJSONRequestBody defines body for PostGamePlayLogStart for application/json ContentType.
type PostGamePlayLogStartJSONRequestBody = PostGamePlayLogStartRequest

// PatchGamePlayLogEndJSONRequestBody defines body for PatchGamePlayLogEnd for application/json ContentType.
type PatchGamePlayLogEndJSONRequestBody = PatchGamePlayLogEndRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PatchEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// ゲーム起動ログの記録
	// (POST /editions/{editionID}/games/{gameID}/plays/start)
	PostGamePlayLogStart(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath) error
	// ゲーム終了ログの記録
	// (PATCH /editions/{editionID}/games/{gameID}/plays/{playLogID}/end)
	PatchGamePlayLogEnd(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// エディションのプレイ統計取得
	// (GET /editions/{editionID}/play-stats)
	GetEditionPlayStats(ctx echo.Context, editionID EditionIDInPath, params GetEditionPlayStatsParams) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームのプレイ統計取得
	// (GET /games/{gameID}/play-stats)
	GetGamePlayStats(ctx echo.Context, gameID GameIDInPath, params GetGamePlayStatsParams) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PatchEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEditionGame(ctx, editionID)
	return err
}

// PostGamePlayLogStart converts echo context to params.
func (w *ServerInterfaceWrapper) PostGamePlayLogStart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGamePlayLogStart(ctx, editionID, gameID)
	return err
}

// PatchGamePlayLogEnd converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGamePlayLogEnd(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGamePlayLogEnd(ctx, editionID, gameID, playLogID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetEditionPlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionPlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEditionPlayStatsParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionPlayStats(ctx, editionID, params)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// GetGamePlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetGamePlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamePlayStatsParams
	// ------------- Optional query parameter "gameVersionID" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameVersionID", ctx.QueryParams(), &params.GameVersionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVersionID: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGamePlayStats(ctx, gameID, params)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "bot" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot", ctx.QueryParams(), &params.Bot)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bot: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PatchEditionGame)
	router.POST(baseURL+"/editions/:editionID/games/:gameID/plays/start", wrapper.PostGamePlayLogStart)
	router.PATCH(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID/end", wrapper.PatchGamePlayLogEnd)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/editions/:editionID/play-stats", wrapper.GetEditionPlayStats)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.GET(baseURL+"/games/:gameID/play-stats", wrapper.GetGamePlayStats)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
