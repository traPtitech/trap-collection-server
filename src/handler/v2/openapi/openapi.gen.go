// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes               = "AdminAuth.Scopes"
	EditionAuthScopes             = "EditionAuth.Scopes"
	EditionGameFileAuthScopes     = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes    = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes    = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes           = "EditionIDAuth.Scopes"
	GameFileVisibilityAuthScopes  = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes  = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes      = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes           = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes          = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	// CreatedAt ジャンルが作成された日時です
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt ジャンルが作成された日時です
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription  `json:"description"`
	Genres      *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	// ジャンルに重複があった場合は400エラーとなります。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	Visibility GameVisibility `json:"visibility"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合はすべてのゲームが取得されます。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreName `json:"genres,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PostEditionGameJSONRequestBody defines body for PostEditionGame for application/json ContentType.
type PostEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PostEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PostEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionGame(ctx, editionID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PostEditionGame)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"OcXg1lcJcjccBxSwqRNT/z8AAP//yt8CMF9bAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
