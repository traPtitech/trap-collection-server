// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AdminAuthScopes                  = "AdminAuth.Scopes"
	EditionAuthScopes                = "EditionAuth.Scopes"
	EditionGameFileAuthScopes        = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes       = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes       = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes              = "EditionIDAuth.Scopes"
	GameCreatorsVisibilityAuthScopes = "GameCreatorsVisibilityAuth.Scopes"
	GameFileVisibilityAuthScopes     = "GameFileVisibilityAuth.Scopes"
	GameImageVisibilityAuthScopes    = "GameImageVisibilityAuth.Scopes"
	GameInfoVisibilityAuthScopes     = "GameInfoVisibilityAuth.Scopes"
	GameMaintainerAuthScopes         = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes              = "GameOwnerAuth.Scopes"
	GameVideoVisibilityAuthScopes    = "GameVideoVisibilityAuth.Scopes"
	TrapMemberAuthScopes             = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videom4v GameVideoMime = "video/m4v"
	Videomkv GameVideoMime = "video/mkv"
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for GameVisibility.
const (
	Limited GameVisibility = "limited"
	Private GameVisibility = "private"
	Public  GameVisibility = "public"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Defines values for GetGamesParamsSort.
const (
	CreatedAt     GetGamesParamsSort = "createdAt"
	LatestVersion GetGamesParamsSort = "latestVersion"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionPlayStats エディションのプレイ統計データです。
type EditionPlayStats struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// EditionName エディション名です。
	EditionName EditionName `json:"editionName"`

	// GameStats エディションに含まれるゲームごとの統計データです。
	GameStats []GamePlayStatsInEdition `json:"gameStats"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ジャンルの名前です。ジャンルが無い場合はこのフィールドはありません。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameCreator defines model for GameCreator.
type GameCreator struct {
	Jobs []GameCreatorJob `json:"jobs"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// GameCreatorJob ゲームクリエイターのjob情報を表します。
type GameCreatorJob struct {
	DisplayName GameCreatorJobDisplayName `json:"displayName"`

	// Id ゲームクリエイターのjobのIDを表します。
	Id GameCreatorJobID `json:"id"`

	// IsCustomJob ユーザーが定義したカスタムjobかどうかを表します。
	IsCustomJob bool `json:"isCustomJob"`
}

// GameCreatorJobDisplayName defines model for GameCreatorJobDisplayName.
type GameCreatorJobDisplayName = string

// GameCreatorJobID ゲームクリエイターのjobのIDを表します。
type GameCreatorJobID = openapi_types.UUID

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameGenre defines model for GameGenre.
type GameGenre struct {
	CreatedAt GameGenreCreatedAt `json:"createdAt"`

	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`

	// Id ジャンルのID(UUID)です。
	Id GameGenreID `json:"id"`

	// Num そのジャンルが含まれるゲームの数です。
	Num int `json:"num"`
}

// GameGenreCreatedAt defines model for GameGenreCreatedAt.
type GameGenreCreatedAt = time.Time

// GameGenreID ジャンルのID(UUID)です。
type GameGenreID = openapi_types.UUID

// GameGenreName ジャンルの名前です。32文字以下です。
type GameGenreName = string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameInfoWithGenres ゲームとそのジャンルの情報です。
type GameInfoWithGenres struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription  `json:"description"`
	Genres      *[]GameGenreName `json:"genres,omitempty"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility GameVisibility `json:"visibility"`
}

// GameName ゲームの名前です。
type GameName = string

// GamePlayLogID ゲームプレイログのID(UUID)です。
type GamePlayLogID = openapi_types.UUID

// GamePlayStats ゲームのプレイ統計データです。
type GamePlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`
}

// GamePlayStatsInEdition エディション内のゲームプレイ統計データです。
type GamePlayStatsInEdition struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// PlayCount 指定期間内のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime 指定期間内のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`
}

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVersionPlayStats ゲームバージョンのプレイ統計データです。
type GameVersionPlayStats struct {
	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// HourlyStats 時間別の統計データです。デフォルトでは1時間ごとの統計を24時間分返します。
	HourlyStats []HourlyPlayStats `json:"hourlyStats"`

	// TotalPlayCount 指定期間内の総プレイ回数です。
	TotalPlayCount int `json:"totalPlayCount"`

	// TotalPlaySeconds 指定期間内の総プレイ時間（秒）です。
	TotalPlaySeconds int `json:"totalPlaySeconds"`

	// VersionName ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	VersionName GameVersionName `json:"versionName"`
}

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GameVisibility ゲームの公開設定です。
// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
// privateは部員はアクセスできます。
// ゲーム作成時、指定がない場合はprivateになります
type GameVisibility string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfoWithGenres `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// HourlyPlayStats 時台別のプレイ統計データです。各時台（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00から2025-01-01T14:59:59+09:00）の統計を返します。
type HourlyPlayStats struct {
	// PlayCount この時台のプレイ回数です。
	PlayCount int `json:"playCount"`

	// PlayTime この時台のプレイ時間（秒）です。
	PlayTime int `json:"playTime"`

	// StartTime この統計データの対象時台の開始時刻です（例：2025-01-01の14時台の場合は2025-01-01T14:00:00+09:00）。
	StartTime time.Time `json:"startTime"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Genres ゲームのジャンルの名前の配列です。ジャンルが無い場合はこのフィールドは省略されます。
	// ジャンルに重複があった場合は400エラーとなります。
	Genres *[]GameGenreName `json:"genres,omitempty"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Visibility ゲームの公開設定です。
	// publicは全てのユーザーが全ての情報・ファイルにアクセスできます。
	// limitedは部員は全ての情報・ファイルに、部員以外はファイル以外にアクセスできます。
	// privateは部員はアクセスできます。
	// ゲーム作成時、指定がない場合はprivateになります
	Visibility *GameVisibility `json:"visibility,omitempty"`
}

// PatchGamePlayLogEndRequest ゲーム終了ログの記録リクエストです。
type PatchGamePlayLogEndRequest struct {
	// EndTime ゲーム終了時刻です。
	EndTime time.Time `json:"endTime"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostGamePlayLogStartRequest ゲーム起動ログの記録リクエストです。
type PostGamePlayLogStartRequest struct {
	// EditionID エディションのIDです。
	EditionID EditionID `json:"editionID"`

	// GameID ゲームのIDです。
	GameID GameID `json:"gameID"`

	// GameVersionID ゲームのバージョンのIDです。
	GameVersionID GameVersionID `json:"gameVersionID"`

	// StartTime ゲーム起動時刻です。
	StartTime time.Time `json:"startTime"`
}

// PostGamePlayLogStartResponse ゲーム起動ログのレスポンスです。PlayLogIDを返却します。
type PostGamePlayLogStartResponse struct {
	// PlayLogID ゲームプレイログのID(UUID)です。
	PlayLogID GamePlayLogID `json:"playLogID"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// PutGameCreatorsRequest defines model for PutGameCreatorsRequest.
type PutGameCreatorsRequest = []PutGameCreatorsRequestItem

// PutGameCreatorsRequestItem defines model for PutGameCreatorsRequestItem.
type PutGameCreatorsRequestItem struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Jobs ゲームクリエイターのjob情報の配列です。
	// 配列の各要素は、既存のjob（プリセットのjob+ゲームにすでにあるjob)のIDを指定するか、
	// 新しいカスタムjobの表示名を指定します。
	// 既存のjobのIDは重複してはいけません。
	// 新しいカスタムjobの表示名は、既にあるカスタムjobの表示名と重複してはいけません。
	Jobs *[]PutGameCreatorsRequestItem_Jobs_Item `json:"jobs,omitempty"`
}

// PutGameCreatorsRequestItemJobs0 既存のゲームクリエイターのjobのIDを指定します。
type PutGameCreatorsRequestItemJobs0 struct {
	// Id ゲームクリエイターのjobのIDを表します。
	Id GameCreatorJobID `json:"id"`
}

// PutGameCreatorsRequestItemJobs1 新しいカスタムjobの表示名を指定します。
type PutGameCreatorsRequestItemJobs1 struct {
	CustomDisplayName GameCreatorJobDisplayName `json:"customDisplayName"`
}

// PutGameCreatorsRequestItem_Jobs_Item defines model for PutGameCreatorsRequestItem.jobs.Item.
type PutGameCreatorsRequestItem_Jobs_Item struct {
	union json.RawMessage
}

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameGenreIDInPath defines model for gameGenreIDInPath.
type GameGenreIDInPath = openapi_types.UUID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVersionIDInQuery defines model for gameVersionIDInQuery.
type GameVersionIDInQuery = openapi_types.UUID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// PeriodEndInQuery defines model for periodEndInQuery.
type PeriodEndInQuery = time.Time

// PeriodStartInQuery defines model for periodStartInQuery.
type PeriodStartInQuery = time.Time

// PlayLogIDInPath defines model for playLogIDInPath.
type PlayLogIDInPath = openapi_types.UUID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// GameInfoForbidden defines model for GameInfoForbidden.
type GameInfoForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetEditionPlayStatsParams defines parameters for GetEditionPlayStats.
type GetEditionPlayStatsParams struct {
	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	// ログインしている部員以外がfalseでリクエストを送った場合はtrueとして扱われます。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合はすべてのゲームが取得されます。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Genre 取得するゲームのジャンルを指定します。指定なしの場合は、ジャンルによる絞り込みを行いません。
	// また、コンマ区切りで配列として複数指定でき、複数指定した場合はそれらすべてのジャンルに当てはまるゲームを返します。
	Genre *[]GameGenreID `form:"genre,omitempty" json:"genre,omitempty"`

	// Name ゲームの名前を指定すると部分一致するゲームを返します。指定なしの場合は名前による絞り込みを行いません。
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort 取得するゲームの並び順を指定します。指定なしの場合は、各ゲームの最新のバージョンが新しい順に取得します。
	Sort *GetGamesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetGamesParamsSort defines parameters for GetGames.
type GetGamesParamsSort string

// PutGameGenresJSONBody defines parameters for PutGameGenres.
type PutGameGenresJSONBody struct {
	Genres *[]GameGenreName `json:"genres,omitempty"`
}

// GetGamePlayStatsParams defines parameters for GetGamePlayStats.
type GetGamePlayStatsParams struct {
	// GameVersionID ゲームバージョンのIDを示すクエリパラメータです。
	// 指定した場合は特定バージョンの統計データを取得し、指定しない場合は全バージョンの統計データを取得します。
	GameVersionID *GameVersionIDInQuery `form:"gameVersionID,omitempty" json:"gameVersionID,omitempty"`

	// Start 統計データ取得の開始日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻から24時間前がデフォルトの開始時刻になります
	// - 指定した場合：指定された時刻から統計データを取得します
	Start *PeriodStartInQuery `form:"start,omitempty" json:"start,omitempty"`

	// End 統計データ取得の終了日時を示すクエリパラメータです。
	// - 指定しない場合：現在時刻がデフォルトの終了時刻になります
	// - 指定した場合：指定された時刻まで統計データを取得します
	End *PeriodEndInQuery `form:"end,omitempty" json:"end,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchGameGenreJSONBody defines parameters for PatchGameGenre.
type PatchGameGenreJSONBody struct {
	// Genre ジャンルの名前です。32文字以下です。
	Genre GameGenreName `json:"genre"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Bot falseの場合botを除外します。
	// デフォルトではbotも含めます。
	Bot *bool `form:"bot,omitempty" json:"bot,omitempty"`

	// IncludeSuspended trueの場合、凍結済みユーザーも含めます。
	// デフォルトでは凍結済みユーザーは含めません。
	IncludeSuspended *bool `form:"includeSuspended,omitempty" json:"includeSuspended,omitempty"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PatchEditionGameJSONRequestBody defines body for PatchEditionGame for application/json ContentType.
type PatchEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGamePlayLogStartJSONRequestBody defines body for PostGamePlayLogStart for application/json ContentType.
type PostGamePlayLogStartJSONRequestBody = PostGamePlayLogStartRequest

// PatchGamePlayLogEndJSONRequestBody defines body for PatchGamePlayLogEnd for application/json ContentType.
type PatchGamePlayLogEndJSONRequestBody = PatchGamePlayLogEndRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PutGameCreatorsJSONRequestBody defines body for PutGameCreators for application/json ContentType.
type PutGameCreatorsJSONRequestBody = PutGameCreatorsRequest

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PutGameGenresJSONRequestBody defines body for PutGameGenres for application/json ContentType.
type PutGameGenresJSONRequestBody PutGameGenresJSONBody

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PatchGameGenreJSONRequestBody defines body for PatchGameGenre for application/json ContentType.
type PatchGameGenreJSONRequestBody PatchGameGenreJSONBody

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// AsPutGameCreatorsRequestItemJobs0 returns the union data inside the PutGameCreatorsRequestItem_Jobs_Item as a PutGameCreatorsRequestItemJobs0
func (t PutGameCreatorsRequestItem_Jobs_Item) AsPutGameCreatorsRequestItemJobs0() (PutGameCreatorsRequestItemJobs0, error) {
	var body PutGameCreatorsRequestItemJobs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPutGameCreatorsRequestItemJobs0 overwrites any union data inside the PutGameCreatorsRequestItem_Jobs_Item as the provided PutGameCreatorsRequestItemJobs0
func (t *PutGameCreatorsRequestItem_Jobs_Item) FromPutGameCreatorsRequestItemJobs0(v PutGameCreatorsRequestItemJobs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePutGameCreatorsRequestItemJobs0 performs a merge with any union data inside the PutGameCreatorsRequestItem_Jobs_Item, using the provided PutGameCreatorsRequestItemJobs0
func (t *PutGameCreatorsRequestItem_Jobs_Item) MergePutGameCreatorsRequestItemJobs0(v PutGameCreatorsRequestItemJobs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPutGameCreatorsRequestItemJobs1 returns the union data inside the PutGameCreatorsRequestItem_Jobs_Item as a PutGameCreatorsRequestItemJobs1
func (t PutGameCreatorsRequestItem_Jobs_Item) AsPutGameCreatorsRequestItemJobs1() (PutGameCreatorsRequestItemJobs1, error) {
	var body PutGameCreatorsRequestItemJobs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPutGameCreatorsRequestItemJobs1 overwrites any union data inside the PutGameCreatorsRequestItem_Jobs_Item as the provided PutGameCreatorsRequestItemJobs1
func (t *PutGameCreatorsRequestItem_Jobs_Item) FromPutGameCreatorsRequestItemJobs1(v PutGameCreatorsRequestItemJobs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePutGameCreatorsRequestItemJobs1 performs a merge with any union data inside the PutGameCreatorsRequestItem_Jobs_Item, using the provided PutGameCreatorsRequestItemJobs1
func (t *PutGameCreatorsRequestItem_Jobs_Item) MergePutGameCreatorsRequestItemJobs1(v PutGameCreatorsRequestItemJobs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PutGameCreatorsRequestItem_Jobs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PutGameCreatorsRequestItem_Jobs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PatchEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// ゲーム起動ログの記録
	// (POST /editions/{editionID}/games/{gameID}/plays/start)
	PostGamePlayLogStart(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath) error

	// (DELETE /editions/{editionID}/games/{gameID}/plays/{playLogID})
	DeleteGamePlayLog(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// ゲーム終了ログの記録
	// (PATCH /editions/{editionID}/games/{gameID}/plays/{playLogID}/end)
	PatchGamePlayLogEnd(ctx echo.Context, editionID EditionIDInPath, gameID GameIDInPath, playLogID PlayLogIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// エディションのプレイ統計取得
	// (GET /editions/{editionID}/play-stats)
	GetEditionPlayStats(ctx echo.Context, editionID EditionIDInPath, params GetEditionPlayStatsParams) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイター一覧の取得
	// (GET /games/{gameID}/creators)
	GetGameCreators(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイター一覧の更新
	// (PUT /games/{gameID}/creators)
	PutGameCreators(ctx echo.Context, gameID GameIDInPath) error
	// ゲームクリエイターのジョブ一覧の取得
	// (GET /games/{gameID}/creators/jobs)
	GetGameCreatorJobs(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームのジャンル編集
	// (PUT /games/{gameID}/genres)
	PutGameGenres(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームのプレイ統計取得
	// (GET /games/{gameID}/play-stats)
	GetGamePlayStats(ctx echo.Context, gameID GameIDInPath, params GetGamePlayStatsParams) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// 全てのジャンルの取得
	// (GET /genres)
	GetGameGenres(ctx echo.Context) error
	// ジャンルの削除
	// (DELETE /genres/{gameGenreID})
	DeleteGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// ジャンル情報の変更
	// (PATCH /genres/{gameGenreID})
	PatchGameGenre(ctx echo.Context, gameGenreID GameGenreIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PatchEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEditionGame(ctx, editionID)
	return err
}

// PostGamePlayLogStart converts echo context to params.
func (w *ServerInterfaceWrapper) PostGamePlayLogStart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGamePlayLogStart(ctx, editionID, gameID)
	return err
}

// DeleteGamePlayLog converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGamePlayLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGamePlayLog(ctx, editionID, gameID, playLogID)
	return err
}

// PatchGamePlayLogEnd converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGamePlayLogEnd(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "playLogID" -------------
	var playLogID PlayLogIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "playLogID", ctx.Param("playLogID"), &playLogID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter playLogID: %s", err))
	}

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGamePlayLogEnd(ctx, editionID, gameID, playLogID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "productKeyID", ctx.Param("productKeyID"), &productKeyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetEditionPlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionPlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "editionID", ctx.Param("editionID"), &editionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEditionPlayStatsParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionPlayStats(ctx, editionID, params)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameInfoVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameCreators converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameCreators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameCreatorsVisibilityAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameCreators(ctx, gameID)
	return err
}

// PutGameCreators converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameCreators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameCreators(ctx, gameID)
	return err
}

// GetGameCreatorJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameCreatorJobs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameCreatorJobs(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameFileID", ctx.Param("gameFileID"), &gameFileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(GameFileVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// PutGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) PutGameGenres(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutGameGenres(ctx, gameID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameImageID", ctx.Param("gameImageID"), &gameImageID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(GameImageVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// GetGamePlayStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetGamePlayStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamePlayStatsParams
	// ------------- Optional query parameter "gameVersionID" -------------

	err = runtime.BindQueryParameter("form", true, false, "gameVersionID", ctx.QueryParams(), &params.GameVersionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVersionID: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGamePlayStats(ctx, gameID, params)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "userID", ctx.Param("userID"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameID", ctx.Param("gameID"), &gameID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameVideoID", ctx.Param("gameVideoID"), &gameVideoID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(GameVideoVisibilityAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetGameGenres converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameGenres(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameGenres(ctx)
	return err
}

// DeleteGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameGenre(ctx, gameGenreID)
	return err
}

// PatchGameGenre converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameGenre(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameGenreID" -------------
	var gameGenreID GameGenreIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "gameGenreID", ctx.Param("gameGenreID"), &gameGenreID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameGenreID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameGenre(ctx, gameGenreID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithOptions("simple", "seatID", ctx.Param("seatID"), &seatID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "bot" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot", ctx.QueryParams(), &params.Bot)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bot: %s", err))
	}

	// ------------- Optional query parameter "includeSuspended" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeSuspended", ctx.QueryParams(), &params.IncludeSuspended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter includeSuspended: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PatchEditionGame)
	router.POST(baseURL+"/editions/:editionID/games/:gameID/plays/start", wrapper.PostGamePlayLogStart)
	router.DELETE(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID", wrapper.DeleteGamePlayLog)
	router.PATCH(baseURL+"/editions/:editionID/games/:gameID/plays/:playLogID/end", wrapper.PatchGamePlayLogEnd)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/editions/:editionID/play-stats", wrapper.GetEditionPlayStats)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/creators", wrapper.GetGameCreators)
	router.PUT(baseURL+"/games/:gameID/creators", wrapper.PutGameCreators)
	router.GET(baseURL+"/games/:gameID/creators/jobs", wrapper.GetGameCreatorJobs)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.PUT(baseURL+"/games/:gameID/genres", wrapper.PutGameGenres)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.GET(baseURL+"/games/:gameID/play-stats", wrapper.GetGamePlayStats)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/genres", wrapper.GetGameGenres)
	router.DELETE(baseURL+"/genres/:gameGenreID", wrapper.DeleteGameGenre)
	router.PATCH(baseURL+"/genres/:gameGenreID", wrapper.PatchGameGenre)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
