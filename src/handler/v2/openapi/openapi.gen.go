// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	AdminAuthScopes            = "AdminAuth.Scopes"
	EditionAuthScopes          = "EditionAuth.Scopes"
	EditionGameFileAuthScopes  = "EditionGameFileAuth.Scopes"
	EditionGameImageAuthScopes = "EditionGameImageAuth.Scopes"
	EditionGameVideoAuthScopes = "EditionGameVideoAuth.Scopes"
	EditionIDAuthScopes        = "EditionIDAuth.Scopes"
	GameMaintainerAuthScopes   = "GameMaintainerAuth.Scopes"
	GameOwnerAuthScopes        = "GameOwnerAuth.Scopes"
	TrapMemberAuthScopes       = "TrapMemberAuth.Scopes"
)

// Defines values for GameFileType.
const (
	Darwin GameFileType = "darwin"
	Jar    GameFileType = "jar"
	Win32  GameFileType = "win32"
)

// Defines values for GameImageMime.
const (
	Imagegif  GameImageMime = "image/gif"
	Imagejpeg GameImageMime = "image/jpeg"
	Imagepng  GameImageMime = "image/png"
)

// Defines values for GameRoleType.
const (
	Maintainer GameRoleType = "maintainer"
	Owner      GameRoleType = "owner"
)

// Defines values for GameVideoMime.
const (
	Videomp4 GameVideoMime = "video/mp4"
)

// Defines values for ProductKeyStatus.
const (
	Active  ProductKeyStatus = "active"
	Revoked ProductKeyStatus = "revoked"
)

// Defines values for SeatStatus.
const (
	Empty SeatStatus = "empty"
	InUse SeatStatus = "in-use"
)

// Edition エディションです。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type Edition struct {
	// CreatedAt エディションが作成された時刻です。
	CreatedAt EditionCreatedAt `json:"createdAt"`

	// Id エディションのIDです。
	Id EditionID `json:"id"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// EditionAccessToken defines model for EditionAccessToken.
type EditionAccessToken struct {
	// AccessToken アクセストークンです。
	// 暗号的にランダムな英数字36文字です。
	AccessToken EditionAccessTokenValue `json:"accessToken"`

	// ExpiresAt アクセストークンの有効期限です。
	ExpiresAt EditionAccessTokenExpiresAt `json:"expiresAt"`
}

// EditionAccessTokenExpiresAt アクセストークンの有効期限です。
type EditionAccessTokenExpiresAt = time.Time

// EditionAccessTokenValue アクセストークンです。
// 暗号的にランダムな英数字36文字です。
type EditionAccessTokenValue = string

// EditionAuthorizeRequest ランチャーのエディション情報取得認可のリクエストです。
type EditionAuthorizeRequest struct {
	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key ProductKeyValue `json:"key"`
}

// EditionCreatedAt エディションが作成された時刻です。
type EditionCreatedAt = time.Time

// EditionGameResponse defines model for EditionGameResponse.
type EditionGameResponse struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Version ゲームのバージョンです。
	// url、filesはゲームの種類に応じていずれかが存在します。
	Version GameVersion `json:"version"`
}

// EditionID エディションのIDです。
type EditionID = openapi_types.UUID

// EditionName エディション名です。
type EditionName = string

// EditionQuestionnaireURL エディションのアンケートのURLです。
type EditionQuestionnaireURL = string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game ゲームの情報です。
type Game struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Maintainers ゲームのmaintainerの一覧です。
	// maintainerがいない場合、このフィールドは存在しません。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	Owners []UserName `json:"owners"`
}

// GameCreatedAt ゲームがtraP Collectionに追加された時刻です。
type GameCreatedAt = time.Time

// GameDescription ゲームの説明です。
// ランチャーでも表示されます。
type GameDescription = string

// GameFile ゲームのファイルのメタ情報です。
type GameFile struct {
	// CreatedAt ゲームファイルが作成された時刻です。
	CreatedAt GameFileCreatedAt `json:"createdAt"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`

	// Id ゲームファイルのIDです。
	Id GameFileID `json:"id"`

	// Md5 ゲームファイルのmd5ハッシュ値です。
	Md5 GameFileMd5 `json:"md5"`

	// Type ゲームファイルのタイプです。
	// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
	// windowsはWindows用の実行ファイル、
	// macはOSX用の実行ファイルです。
	Type GameFileType `json:"type"`
}

// GameFileContent ゲームの実行ファイルやデータをzipしたバイナリです。
type GameFileContent = openapi_types.File

// GameFileCreatedAt ゲームファイルが作成された時刻です。
type GameFileCreatedAt = time.Time

// GameFileEntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
type GameFileEntryPoint = string

// GameFileID ゲームファイルのIDです。
type GameFileID = openapi_types.UUID

// GameFileMd5 ゲームファイルのmd5ハッシュ値です。
type GameFileMd5 = string

// GameFileType ゲームファイルのタイプです。
// jarはJavaで起動しWindows、OSXの両方で実行できるもの、
// windowsはWindows用の実行ファイル、
// macはOSX用の実行ファイルです。
type GameFileType string

// GameID ゲームのIDです。
type GameID = openapi_types.UUID

// GameImage ゲームの画像のメタ情報です。
type GameImage struct {
	// CreatedAt ゲーム画像の作成時刻です。
	CreatedAt GameImageCreatedAt `json:"createdAt"`

	// Id ゲーム画像のIDです。
	Id GameImageID `json:"id"`

	// Mime ゲーム画像のmimeです。
	Mime GameImageMime `json:"mime"`
}

// GameImageContent ゲーム画像のバイナリです。
type GameImageContent = openapi_types.File

// GameImageCreatedAt ゲーム画像の作成時刻です。
type GameImageCreatedAt = time.Time

// GameImageID ゲーム画像のIDです。
type GameImageID = openapi_types.UUID

// GameImageMime ゲーム画像のmimeです。
type GameImageMime string

// GameInfo ゲームの情報です。
type GameInfo struct {
	// CreatedAt ゲームがtraP Collectionに追加された時刻です。
	CreatedAt GameCreatedAt `json:"createdAt"`

	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Id ゲームのIDです。
	Id GameID `json:"id"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// GameName ゲームの名前です。
type GameName = string

// GameRoleRequest ゲームのロールを指定するリクエストです。
type GameRoleRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Type ゲームの管理権限の種類です。
	// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
	// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
	Type *GameRoleType `json:"type,omitempty"`
}

// GameRoleType ゲームの管理権限の種類です。
// ownerはゲームの所有者で、ゲーム情報の変更や管理者の変更ができます。
// maintainerはゲームのメンテナーで、ゲーム情報の変更のみできます。
type GameRoleType string

// GameURL ゲームのURLの値です。
type GameURL = string

// GameVersion ゲームのバージョンです。
// url、filesはゲームの種類に応じていずれかが存在します。
type GameVersion struct {
	// CreatedAt ゲームのバージョンが作成された時刻です。
	CreatedAt GameVersionCreatedAt `json:"createdAt"`

	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// Id ゲームのバージョンのIDです。
	Id GameVersionID `json:"id"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// GameVersionCreatedAt ゲームのバージョンが作成された時刻です。
type GameVersionCreatedAt = time.Time

// GameVersionDescription ゲームのバージョンの説明です。
// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
type GameVersionDescription = string

// GameVersionFiles ゲームバージョンに紐づいたファイルの情報です。
type GameVersionFiles struct {
	// Darwin ゲームファイルのIDです。
	Darwin *GameFileID `json:"darwin,omitempty"`

	// Jar ゲームファイルのIDです。
	Jar *GameFileID `json:"jar,omitempty"`

	// Win32 ゲームファイルのIDです。
	Win32 *GameFileID `json:"win32,omitempty"`
}

// GameVersionID ゲームのバージョンのIDです。
type GameVersionID = openapi_types.UUID

// GameVersionName ゲームのバージョン名です。
// セマンティックバージョニングに沿った文字列が許容されます。
type GameVersionName = string

// GameVideo ゲームの動画のメタ情報です。
type GameVideo struct {
	// CreatedAt ゲーム紹介動画の作成時刻です。
	CreatedAt GameVideoCreatedAt `json:"createdAt"`

	// Id ゲーム紹介動画のIDです。
	Id GameVideoID `json:"id"`

	// Mime ゲーム紹介動画のmimeです。
	Mime GameVideoMime `json:"mime"`
}

// GameVideoContent ゲーム紹介動画のバイナリです。
type GameVideoContent = openapi_types.File

// GameVideoCreatedAt ゲーム紹介動画の作成時刻です。
type GameVideoCreatedAt = time.Time

// GameVideoID ゲーム紹介動画のIDです。
type GameVideoID = openapi_types.UUID

// GameVideoMime ゲーム紹介動画のmimeです。
type GameVideoMime string

// GetGameVersionsResponse ゲームバージョンの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームバージョンの数もnumで返しています。
type GetGameVersionsResponse struct {
	// Num limit、offsetが適用される前のゲームバージョンの数です。
	Num int `json:"num"`

	// Versions limit、offsetが適用された後のゲームバージョンの一覧です。
	Versions []GameVersion `json:"versions"`
}

// GetGamesResponse ゲームの一覧を取得します。
// ページングのために、limit、offsetを適用する前のゲームの数をnumで返しています。
type GetGamesResponse struct {
	// Games limit、offsetが適用された後のゲームの一覧です。
	Games []GameInfo `json:"games"`

	// Num limit、offsetが適用される前のゲームの数です。
	Num int `json:"num"`
}

// NewEdition エディションを新しく作成する際に必要な情報です。
// questionnaireは工大祭などのアンケートが必要な際のみ存在します。
type NewEdition struct {
	GameVersions []GameVersionID `json:"gameVersions"`

	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// NewGame ゲームを新しく作成する際に必要な情報です。
type NewGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Maintainers ゲームのmaintainerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーを含むownerと重複するユーザーが存在した場合、
	// 400エラーとなります。
	Maintainers *[]UserName `json:"maintainers,omitempty"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`

	// Owners ゲームのownerの一覧です。
	// 指定されない場合、空配列として扱われます。
	// ゲームの作成を実行したユーザーは、このリストに含まれていなくてもownerとなります。
	// また、このリストにゲームの作成を実行したユーザーが含まれていた場合、
	// 400エラーになります。
	Owners *[]UserName `json:"owners,omitempty"`
}

// NewGameFile ゲームのファイルを新しく作成する際に必要な情報です。
type NewGameFile struct {
	// Content ゲームの実行ファイルやデータをzipしたバイナリです。
	Content GameFileContent `json:"content"`

	// EntryPoint ゲームファイルの解凍後の実行ファイルのパスです。
	EntryPoint GameFileEntryPoint `json:"entryPoint"`
	Type       string             `json:"type"`
}

// NewGameImage ゲームの画像を新しく作成する際に必要な情報です。
type NewGameImage struct {
	// Content ゲーム画像のバイナリです。
	Content GameImageContent `json:"content"`
}

// NewGameVersion 新しいゲームのバージョンの作成に必要な情報です。
// url、filesはゲームの種類に応じていずれかが存在します。
type NewGameVersion struct {
	// Description ゲームのバージョンの説明です。
	// 主にゲームの開発者向けの情報で、ランチャーでは表示されません。
	Description GameVersionDescription `json:"description"`

	// Files ゲームバージョンに紐づいたファイルの情報です。
	Files *GameVersionFiles `json:"files,omitempty"`

	// ImageID ゲーム画像のIDです。
	ImageID GameImageID `json:"imageID"`

	// Name ゲームのバージョン名です。
	// セマンティックバージョニングに沿った文字列が許容されます。
	Name GameVersionName `json:"name"`

	// Url ゲームのURLの値です。
	Url *GameURL `json:"url,omitempty"`

	// VideoID ゲーム紹介動画のIDです。
	VideoID GameVideoID `json:"videoID"`
}

// NewGameVideo ゲームの動画を新しく作成する際に必要な情報です。
type NewGameVideo struct {
	// Content ゲーム紹介動画のバイナリです。
	Content GameVideoContent `json:"content"`
}

// PatchEdition エディションの情報を修正する際に必要な情報です。
type PatchEdition struct {
	// Name エディション名です。
	Name EditionName `json:"name"`

	// Questionnaire エディションのアンケートのURLです。
	Questionnaire *EditionQuestionnaireURL `json:"questionnaire,omitempty"`
}

// PatchEditionGameRequest エディションのゲームを変更するためのリクエストです。
type PatchEditionGameRequest struct {
	GameVersionIDs []GameVersionID `json:"gameVersionIDs"`
}

// PatchGame ゲームの情報を修正する際に必要な情報です。
type PatchGame struct {
	// Description ゲームの説明です。
	// ランチャーでも表示されます。
	Description GameDescription `json:"description"`

	// Name ゲームの名前です。
	Name GameName `json:"name"`
}

// PatchSeatStatusRequest 席の着席状態を変更するためのリクエストです。
type PatchSeatStatusRequest struct {
	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// PostSeatRequest 席数を変更するためのリクエストです。
type PostSeatRequest struct {
	// Num 席数です。
	Num int `json:"num"`
}

// ProductKey defines model for ProductKey.
type ProductKey struct {
	// CreatedAt プロダクトキーが作成された時刻です。
	CreatedAt ProductKeyCreatedAt `json:"createdAt"`

	// Id プロダクトキーのIDです。
	Id ProductKeyID `json:"id"`

	// Key プロダクトキーの値です。
	// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
	Key    ProductKeyValue  `json:"key"`
	Status ProductKeyStatus `json:"status"`
}

// ProductKeyCreatedAt プロダクトキーが作成された時刻です。
type ProductKeyCreatedAt = time.Time

// ProductKeyID プロダクトキーのIDです。
type ProductKeyID = openapi_types.UUID

// ProductKeyStatus defines model for ProductKeyStatus.
type ProductKeyStatus string

// ProductKeyValue プロダクトキーの値です。
// 暗号的にランダムな英数字5文字をハイフン区切りで5つ並べたものです。
type ProductKeyValue = string

// Seat 席の情報です。
type Seat struct {
	// Id 席のIDです。
	Id SeatID `json:"id"`

	// Status 席の状態です。
	// in-useは使用中、emptyは空席です。
	Status SeatStatus `json:"status"`
}

// SeatID 席のIDです。
type SeatID = int

// SeatStatus 席の状態です。
// in-useは使用中、emptyは空席です。
type SeatStatus string

// User ユーザー
type User struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`

	// Name ユーザー名です。
	// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
	Name UserName `json:"name"`
}

// UserID ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserID = openapi_types.UUID

// UserName ユーザー名です。
// traQのユーザーのUUIDでないmazreanなどのIDと対応します。
type UserName = string

// UserRequest ユーザーを指定するリクエストです。
type UserRequest struct {
	// Id ユーザーのIDです。
	// traQのユーザーのUUIDと対応します。
	Id UserID `json:"id"`
}

// AuthorizationCodeInQuery defines model for authorizationCodeInQuery.
type AuthorizationCodeInQuery = string

// EditionIDInPath defines model for editionIDInPath.
type EditionIDInPath = openapi_types.UUID

// GameFileIDInPath ゲームファイルのIDです。
type GameFileIDInPath = GameFileID

// GameIDInPath ゲームのIDです。
type GameIDInPath = GameID

// GameImageIDInPath ゲーム画像のIDです。
type GameImageIDInPath = GameImageID

// GameVideoIDInPath ゲーム紹介動画のIDです。
type GameVideoIDInPath = GameVideoID

// ProductKeyIDInPath defines model for productKeyIDInPath.
type ProductKeyIDInPath = openapi_types.UUID

// ProductKeyNumInQuery defines model for productKeyNumInQuery.
type ProductKeyNumInQuery = int

// ProductKeyStatusInQuery defines model for productKeyStatusInQuery.
type ProductKeyStatusInQuery = ProductKeyStatus

// SeatIDInPath 席のIDです。
type SeatIDInPath = SeatID

// UserIDInPath ユーザーのIDです。
// traQのユーザーのUUIDと対応します。
type UserIDInPath = UserID

// AdminForbidden defines model for AdminForbidden.
type AdminForbidden = Error

// EditionForbidden defines model for EditionForbidden.
type EditionForbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// TraPUnauthorized defines model for TraPUnauthorized.
type TraPUnauthorized = Error

// GetProductKeysParams defines parameters for GetProductKeys.
type GetProductKeysParams struct {
	// Status プロダクトキーのステータスを示すクエリパラメータです。
	// 指定がない場合は全てのステータスのプロダクトキーが返されます。
	Status *ProductKeyStatusInQuery `form:"status,omitempty" json:"status,omitempty"`
}

// PostProductKeyParams defines parameters for PostProductKey.
type PostProductKeyParams struct {
	// Num 生成するプロダクトキーの数を示すクエリパラメータです。
	Num ProductKeyNumInQuery `form:"num" json:"num"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// All trueを指定すると、全てのゲーム、
	// falseを指定すると、ログイン中のユーザーが作成したゲームのみを返します。
	// デフォルトはtrueです。
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Limit 取得するゲームの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetGameVersionParams defines parameters for GetGameVersion.
type GetGameVersionParams struct {
	// Limit 取得するゲームバージョンの上限数を指定します。
	// 指定なしの場合は制限なしです。
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset 取得するゲームバージョンの開始位置を指定します。
	// 指定なしの場合は0となります。
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetCallbackParams defines parameters for GetCallback.
type GetCallbackParams struct {
	// Code OAuth 2.0のAuthorization Codeです。
	Code AuthorizationCodeInQuery `form:"code" json:"code"`
}

// PostAdminJSONRequestBody defines body for PostAdmin for application/json ContentType.
type PostAdminJSONRequestBody = UserRequest

// PostEditionJSONRequestBody defines body for PostEdition for application/json ContentType.
type PostEditionJSONRequestBody = NewEdition

// PostEditionAuthorizeJSONRequestBody defines body for PostEditionAuthorize for application/json ContentType.
type PostEditionAuthorizeJSONRequestBody = EditionAuthorizeRequest

// PatchEditionJSONRequestBody defines body for PatchEdition for application/json ContentType.
type PatchEditionJSONRequestBody = PatchEdition

// PostEditionGameJSONRequestBody defines body for PostEditionGame for application/json ContentType.
type PostEditionGameJSONRequestBody = PatchEditionGameRequest

// PostGameJSONRequestBody defines body for PostGame for application/json ContentType.
type PostGameJSONRequestBody = NewGame

// PatchGameJSONRequestBody defines body for PatchGame for application/json ContentType.
type PatchGameJSONRequestBody = PatchGame

// PostGameFileMultipartRequestBody defines body for PostGameFile for multipart/form-data ContentType.
type PostGameFileMultipartRequestBody = NewGameFile

// PostGameImageMultipartRequestBody defines body for PostGameImage for multipart/form-data ContentType.
type PostGameImageMultipartRequestBody = NewGameImage

// PatchGameRoleJSONRequestBody defines body for PatchGameRole for application/json ContentType.
type PatchGameRoleJSONRequestBody = GameRoleRequest

// PostGameVersionJSONRequestBody defines body for PostGameVersion for application/json ContentType.
type PostGameVersionJSONRequestBody = NewGameVersion

// PostGameVideoMultipartRequestBody defines body for PostGameVideo for multipart/form-data ContentType.
type PostGameVideoMultipartRequestBody = NewGameVideo

// PostSeatJSONRequestBody defines body for PostSeat for application/json ContentType.
type PostSeatJSONRequestBody = PostSeatRequest

// PatchSeatStatusJSONRequestBody defines body for PatchSeatStatus for application/json ContentType.
type PatchSeatStatusJSONRequestBody = PatchSeatStatusRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// traPの管理者一覧取得
	// (GET /admins)
	GetAdmins(ctx echo.Context) error
	// traP Collection全体の管理者追加
	// (POST /admins)
	PostAdmin(ctx echo.Context) error
	// traP Collection全体の管理者削除
	// (DELETE /admins/{userID})
	DeleteAdmin(ctx echo.Context, userID UserIDInPath) error
	// エディション一覧の取得
	// (GET /editions)
	GetEditions(ctx echo.Context) error
	// エディションの作成
	// (POST /editions)
	PostEdition(ctx echo.Context) error
	// ランチャーの認可リクエスト
	// (POST /editions/authorize)
	PostEditionAuthorize(ctx echo.Context) error
	// エディション情報の取得
	// (GET /editions/info)
	GetEditionInfo(ctx echo.Context) error
	// エディションの削除
	// (DELETE /editions/{editionID})
	DeleteEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の取得
	// (GET /editions/{editionID})
	GetEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディション情報の変更
	// (PATCH /editions/{editionID})
	PatchEdition(ctx echo.Context, editionID EditionIDInPath) error
	// エディションに紐づくゲームの一覧の取得
	// (GET /editions/{editionID}/games)
	GetEditionGames(ctx echo.Context, editionID EditionIDInPath) error
	// エディションのゲームの変更
	// (PATCH /editions/{editionID}/games)
	PostEditionGame(ctx echo.Context, editionID EditionIDInPath) error
	// プロダクトキーの一覧の取得
	// (GET /editions/{editionID}/keys)
	GetProductKeys(ctx echo.Context, editionID EditionIDInPath, params GetProductKeysParams) error
	// プロダクトキーの生成
	// (POST /editions/{editionID}/keys)
	PostProductKey(ctx echo.Context, editionID EditionIDInPath, params PostProductKeyParams) error
	// プロダクトキーの再有効化
	// (POST /editions/{editionID}/keys/{productKeyID}/activate)
	PostActivateProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// プロダクトキーの失効
	// (POST /editions/{editionID}/keys/{productKeyID}/revoke)
	PostRevokeProductKey(ctx echo.Context, editionID EditionIDInPath, productKeyID ProductKeyIDInPath) error
	// ゲーム一覧の取得
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// ゲームの追加
	// (POST /games)
	PostGame(ctx echo.Context) error
	// ゲームの削除
	// (DELETE /games/{gameID})
	DeleteGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム情報の取得
	// (GET /games/{gameID})
	GetGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの情報の変更
	// (PATCH /games/{gameID})
	PatchGame(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイル一覧の取得
	// (GET /games/{gameID}/files)
	GetGameFiles(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルの作成
	// (POST /games/{gameID}/files)
	PostGameFile(ctx echo.Context, gameID GameIDInPath) error
	// ゲームファイルのバイナリの取得
	// (GET /games/{gameID}/files/{gameFileID})
	GetGameFile(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲームファイルのメタ情報の取得
	// (GET /games/{gameID}/files/{gameFileID}/meta)
	GetGameFileMeta(ctx echo.Context, gameID GameIDInPath, gameFileID GameFileIDInPath) error
	// ゲーム画像一覧の取得
	// (GET /games/{gameID}/images)
	GetGameImages(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像の作成
	// (POST /games/{gameID}/images)
	PostGameImage(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム画像のバイナリの取得
	// (GET /games/{gameID}/images/{gameImageID})
	GetGameImage(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲーム画像のメタ情報の取得
	// (GET /games/{gameID}/images/{gameImageID}/meta)
	GetGameImageMeta(ctx echo.Context, gameID GameIDInPath, gameImageID GameImageIDInPath) error
	// ゲームの管理権限の変更
	// (PATCH /games/{gameID}/roles)
	PatchGameRole(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの管理権限の削除
	// (DELETE /games/{gameID}/roles/{userID})
	DeleteGameRole(ctx echo.Context, gameID GameIDInPath, userID UserIDInPath) error
	// ゲームバージョン一覧の取得
	// (GET /games/{gameID}/versions)
	GetGameVersion(ctx echo.Context, gameID GameIDInPath, params GetGameVersionParams) error
	// ゲームのバージョンの作成
	// (POST /games/{gameID}/versions)
	PostGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲームの最新バージョンの取得
	// (GET /games/{gameID}/versions/latest)
	GetLatestGameVersion(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画一覧の取得
	// (GET /games/{gameID}/videos)
	GetGameVideos(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画の作成
	// (POST /games/{gameID}/videos)
	PostGameVideo(ctx echo.Context, gameID GameIDInPath) error
	// ゲーム動画のバイナリの取得
	// (GET /games/{gameID}/videos/{gameVideoID})
	GetGameVideo(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// ゲーム動画のメタ情報の取得
	// (GET /games/{gameID}/videos/{gameVideoID}/meta)
	GetGameVideoMeta(ctx echo.Context, gameID GameIDInPath, gameVideoID GameVideoIDInPath) error
	// traQのOAuth 2.0のコールバック
	// (GET /oauth2/callback)
	GetCallback(ctx echo.Context, params GetCallbackParams) error
	// OAuth 2.0のCode Verifierなどのセッションへの設定とtraQへのリダイレクト
	// (GET /oauth2/code)
	GetCode(ctx echo.Context) error
	// traP Collectionの管理画面からのログアウト
	// (POST /oauth2/logout)
	PostLogout(ctx echo.Context) error
	// 座席一覧の取得
	// (GET /seats)
	GetSeats(ctx echo.Context) error
	// 席数の変更
	// (POST /seats)
	PostSeat(ctx echo.Context) error
	// 席の変更
	// (PATCH /seats/{seatID})
	PatchSeatStatus(ctx echo.Context, seatID SeatIDInPath) error
	// traPのメンバー一覧取得
	// (GET /users)
	GetUsers(ctx echo.Context) error
	// ログイン中ユーザーの情報の取得
	// (GET /users/me)
	GetMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdmins(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdmins(ctx)
	return err
}

// PostAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdmin(ctx)
	return err
}

// DeleteAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAdmin(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAdmin(ctx, userID)
	return err
}

// GetEditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditions(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditions(ctx)
	return err
}

// PostEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdition(ctx echo.Context) error {
	var err error

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdition(ctx)
	return err
}

// PostEditionAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionAuthorize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionAuthorize(ctx)
	return err
}

// GetEditionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionInfo(ctx)
	return err
}

// DeleteEdition converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdition(ctx, editionID)
	return err
}

// GetEdition converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdition(ctx, editionID)
	return err
}

// PatchEdition converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEdition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEdition(ctx, editionID)
	return err
}

// GetEditionGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetEditionGames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionIDAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEditionGames(ctx, editionID)
	return err
}

// PostEditionGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostEditionGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEditionGame(ctx, editionID)
	return err
}

// GetProductKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductKeysParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductKeys(ctx, editionID, params)
	return err
}

// PostProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProductKeyParams
	// ------------- Required query parameter "num" -------------

	err = runtime.BindQueryParameter("form", true, true, "num", ctx.QueryParams(), &params.Num)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductKey(ctx, editionID, params)
	return err
}

// PostActivateProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostActivateProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "productKeyID", runtime.ParamLocationPath, ctx.Param("productKeyID"), &productKeyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostActivateProductKey(ctx, editionID, productKeyID)
	return err
}

// PostRevokeProductKey converts echo context to params.
func (w *ServerInterfaceWrapper) PostRevokeProductKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "editionID" -------------
	var editionID EditionIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "editionID", runtime.ParamLocationPath, ctx.Param("editionID"), &editionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editionID: %s", err))
	}

	// ------------- Path parameter "productKeyID" -------------
	var productKeyID ProductKeyIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "productKeyID", runtime.ParamLocationPath, ctx.Param("productKeyID"), &productKeyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productKeyID: %s", err))
	}

	ctx.Set(AdminAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRevokeProductKey(ctx, editionID, productKeyID)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// PostGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostGame(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGame(ctx)
	return err
}

// DeleteGame converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGame(ctx, gameID)
	return err
}

// GetGame converts echo context to params.
func (w *ServerInterfaceWrapper) GetGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGame(ctx, gameID)
	return err
}

// PatchGame converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGame(ctx, gameID)
	return err
}

// GetGameFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFiles(ctx, gameID)
	return err
}

// PostGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameFile(ctx, gameID)
	return err
}

// GetGameFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameFileID", runtime.ParamLocationPath, ctx.Param("gameFileID"), &gameFileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFile(ctx, gameID, gameFileID)
	return err
}

// GetGameFileMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameFileMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameFileID" -------------
	var gameFileID GameFileIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameFileID", runtime.ParamLocationPath, ctx.Param("gameFileID"), &gameFileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameFileID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionGameFileAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameFileMeta(ctx, gameID, gameFileID)
	return err
}

// GetGameImages converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImages(ctx, gameID)
	return err
}

// PostGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameImage(ctx, gameID)
	return err
}

// GetGameImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameImageID", runtime.ParamLocationPath, ctx.Param("gameImageID"), &gameImageID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImage(ctx, gameID, gameImageID)
	return err
}

// GetGameImageMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameImageMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameImageID" -------------
	var gameImageID GameImageIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameImageID", runtime.ParamLocationPath, ctx.Param("gameImageID"), &gameImageID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameImageID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionGameImageAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameImageMeta(ctx, gameID, gameImageID)
	return err
}

// PatchGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) PatchGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchGameRole(ctx, gameID)
	return err
}

// DeleteGameRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGameRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "userID" -------------
	var userID UserIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "userID", runtime.ParamLocationPath, ctx.Param("userID"), &userID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userID: %s", err))
	}

	ctx.Set(GameOwnerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteGameRole(ctx, gameID, userID)
	return err
}

// GetGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameVersionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVersion(ctx, gameID, params)
	return err
}

// PostGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVersion(ctx, gameID)
	return err
}

// GetLatestGameVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestGameVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestGameVersion(ctx, gameID)
	return err
}

// GetGameVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideos(ctx, gameID)
	return err
}

// PostGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) PostGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	ctx.Set(GameMaintainerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostGameVideo(ctx, gameID)
	return err
}

// GetGameVideo converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameVideoID", runtime.ParamLocationPath, ctx.Param("gameVideoID"), &gameVideoID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideo(ctx, gameID, gameVideoID)
	return err
}

// GetGameVideoMeta converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameVideoMeta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "gameID" -------------
	var gameID GameIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameID", runtime.ParamLocationPath, ctx.Param("gameID"), &gameID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameID: %s", err))
	}

	// ------------- Path parameter "gameVideoID" -------------
	var gameVideoID GameVideoIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "gameVideoID", runtime.ParamLocationPath, ctx.Param("gameVideoID"), &gameVideoID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gameVideoID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionGameVideoAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGameVideoMeta(ctx, gameID, gameVideoID)
	return err
}

// GetCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetCallback(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCallbackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCallback(ctx, params)
	return err
}

// GetCode converts echo context to params.
func (w *ServerInterfaceWrapper) GetCode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCode(ctx)
	return err
}

// PostLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogout(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLogout(ctx)
	return err
}

// GetSeats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSeats(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSeats(ctx)
	return err
}

// PostSeat converts echo context to params.
func (w *ServerInterfaceWrapper) PostSeat(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSeat(ctx)
	return err
}

// PatchSeatStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSeatStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "seatID" -------------
	var seatID SeatIDInPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "seatID", runtime.ParamLocationPath, ctx.Param("seatID"), &seatID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter seatID: %s", err))
	}

	ctx.Set(TrapMemberAuthScopes, []string{})

	ctx.Set(EditionAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSeatStatus(ctx, seatID)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(TrapMemberAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/admins", wrapper.GetAdmins)
	router.POST(baseURL+"/admins", wrapper.PostAdmin)
	router.DELETE(baseURL+"/admins/:userID", wrapper.DeleteAdmin)
	router.GET(baseURL+"/editions", wrapper.GetEditions)
	router.POST(baseURL+"/editions", wrapper.PostEdition)
	router.POST(baseURL+"/editions/authorize", wrapper.PostEditionAuthorize)
	router.GET(baseURL+"/editions/info", wrapper.GetEditionInfo)
	router.DELETE(baseURL+"/editions/:editionID", wrapper.DeleteEdition)
	router.GET(baseURL+"/editions/:editionID", wrapper.GetEdition)
	router.PATCH(baseURL+"/editions/:editionID", wrapper.PatchEdition)
	router.GET(baseURL+"/editions/:editionID/games", wrapper.GetEditionGames)
	router.PATCH(baseURL+"/editions/:editionID/games", wrapper.PostEditionGame)
	router.GET(baseURL+"/editions/:editionID/keys", wrapper.GetProductKeys)
	router.POST(baseURL+"/editions/:editionID/keys", wrapper.PostProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/activate", wrapper.PostActivateProductKey)
	router.POST(baseURL+"/editions/:editionID/keys/:productKeyID/revoke", wrapper.PostRevokeProductKey)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.POST(baseURL+"/games", wrapper.PostGame)
	router.DELETE(baseURL+"/games/:gameID", wrapper.DeleteGame)
	router.GET(baseURL+"/games/:gameID", wrapper.GetGame)
	router.PATCH(baseURL+"/games/:gameID", wrapper.PatchGame)
	router.GET(baseURL+"/games/:gameID/files", wrapper.GetGameFiles)
	router.POST(baseURL+"/games/:gameID/files", wrapper.PostGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID", wrapper.GetGameFile)
	router.GET(baseURL+"/games/:gameID/files/:gameFileID/meta", wrapper.GetGameFileMeta)
	router.GET(baseURL+"/games/:gameID/images", wrapper.GetGameImages)
	router.POST(baseURL+"/games/:gameID/images", wrapper.PostGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID", wrapper.GetGameImage)
	router.GET(baseURL+"/games/:gameID/images/:gameImageID/meta", wrapper.GetGameImageMeta)
	router.PATCH(baseURL+"/games/:gameID/roles", wrapper.PatchGameRole)
	router.DELETE(baseURL+"/games/:gameID/roles/:userID", wrapper.DeleteGameRole)
	router.GET(baseURL+"/games/:gameID/versions", wrapper.GetGameVersion)
	router.POST(baseURL+"/games/:gameID/versions", wrapper.PostGameVersion)
	router.GET(baseURL+"/games/:gameID/versions/latest", wrapper.GetLatestGameVersion)
	router.GET(baseURL+"/games/:gameID/videos", wrapper.GetGameVideos)
	router.POST(baseURL+"/games/:gameID/videos", wrapper.PostGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID", wrapper.GetGameVideo)
	router.GET(baseURL+"/games/:gameID/videos/:gameVideoID/meta", wrapper.GetGameVideoMeta)
	router.GET(baseURL+"/oauth2/callback", wrapper.GetCallback)
	router.GET(baseURL+"/oauth2/code", wrapper.GetCode)
	router.POST(baseURL+"/oauth2/logout", wrapper.PostLogout)
	router.GET(baseURL+"/seats", wrapper.GetSeats)
	router.POST(baseURL+"/seats", wrapper.PostSeat)
	router.PATCH(baseURL+"/seats/:seatID", wrapper.PatchSeatStatus)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.GET(baseURL+"/users/me", wrapper.GetMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9fXcTR5b3V/HRs3+QXRnJNmQnzsmZwwDJshMSB0J2zxN45jRSYzrRW1otiIf1c9Qt",
	"DH6R1455cSAQh+BgYa3lZJjJGBPwhym3ZH+LPVXV1V3dXd1drRdb9ugfsKTuerl176/uvXXvrRuRRDad",
	"y2bEjJKPDN+I5ARZSIuKKKNPQkG5mpWlPwuKlM2czCbFM5lPCqI8Bn9LivmELOXgL5HhyMcnCsrVvsGj",
	"caDWTtBv9cHXgLoC1AegqF3MRKIRCb7wFWonGskIaTEyHElkk2IkGpHFrwqSLCYjw4pcEKORfOKqmBZg",
	"d8pYDj6XV2QpMxoZH49GxKQEOzhz6kxmRFCuuscEtAoo3QbaU6D9HZRWQOkFUGtnTgFtobG8CcdT+gZo",
	"L+G/peeg9ASUfgPaFmOoOdi6OVKzW9/hXsnKaUGJDEcKBSkZiTKGPyqkxfellOg3/r/AMZV+AGoNlO4B",
	"7QnQlkGp2o5ZWL37TuOfZPFKZDjyf2IWl8Twr/nYB1YTZD58c2nL4FscOD3otDDKOfLG3Vd6aa5tU8Ad",
	"tzYPow0ymc+kpJjlm4w+c69x91W7JmN03NJkSBtwMjk5mywklD+KYz6zKS2C0hooFYG2DkqTQFuDA27D",
	"hOjOWxRzq6mPCmlP+GzcXapPzsNBaTNes6rf+9malraO0G01eGYOoM0U0r4zSgtfS+lCOjI8EI9HI2kp",
	"Y3wy5yZlFHFUlB2TO68ISiHvOT+vOaG1uWWMXXsZZn718m299hCoZaCuAvWm/sNf9flJoK7rExWgPmO0",
	"DUGUOYryztZdoN4DWhmobwLIl0fzjPBy9YiDQIhqeVFQvJla31hrBwvjTpoWx/P4dTjcQl6U/WTwGRrR",
	"r6D0W8uDxl01PegL+PVxOGpZzOeymbyI9JgTybSUeT8rX5aSSTEDv0lkM4qYUZCSk8ulpARSVmJf5LPo",
	"Z77+TstyVsbd2YkiwP7QbGnWrDL5bDwaOY1Vij0c4B9EQRblndXZnQoWwx+RxL1CazaJVmsd6UvlndVl",
	"oD5FEnUTglNRvZgBmgbURaDOAXW9vvgjUKv1R1P69Mv6o6XdB/NALeuTt9EsjZcCCXAmo4hyRkidF+Vr",
	"ooxH3XEabL++B7QpoM4Atba9OVl/tIQmtYrGXEF8C8Gh8WCzcRf/tOQ7EaDeQRjzP4iIjyH5IOrQ6EIa",
	"KKpA+xvaiOcNHCzNA+1noN1EGt4LqO2VngO1tvvwkV6Daqs+t75Tel0vrgC1vFv9Fo6REqbxaORTWRi5",
	"kCEKO5ScTtNPkYVPgFqjNP8VoNYIT5XJnBEPYKo6eYc8C0kL1DJmJciFpRKlsofkpnGCFkjyDdFCJEji",
	"v4XUiJzNibIiQXC4IqTyYpTDcjCp/VVBzMPnMoIki3DD+ftP+vJK46c1NMvnhjjB1f8FLfEknMLWxM4z",
	"Fairuw+/gw+oW/rat/qjCpo7vefkqKHdiCRkUVDE5AklcJHw1E6az49HI1KS8y0ImQSCuV74CD46Ho3Y",
	"KMH57if0OxfOfRjBYE3g/vMI0qPQYKLU/C+Z+kf28hdiQqFg80QiIebzn2a/FIOX2U5ewf4mx+ipvj4T",
	"UgVEBfHrnCSLee5Foto4bb7qpAI9NLoLPjqcpofkZG0vqK/ZQZzeqk01NykoYr8iocVx6LqscWAahRiD",
	"pd09XNTn/t54eBMiAoTiF1Btg3bL6s7ML/V7P+tri0Nv1+/f1tcW7WMVvxbSuRQc2cDg0LHjb//r796J",
	"C5cTSfEK63MkCjXeD8XMKFRuht5GKi/9MScocG+KDEc+j/e/I/T/+UT//710Y+jtcT8KEBQ+JyIRCYs+",
	"xnxVUHpK1GQnHtVLE/oPv+hz9/U3izurs/rcOtpFVg3FGdPVRhc7638pjvHrrgarO1gUNuHDjidp7AqG",
	"1/L260fIBDJ2yvoDTZ981QIbQoPynKEEogVIpT6+Ehn+nMOmzlzJRsajoaDkmijnjX0m0Mo1HnXSkzTh",
	"puklnv2p2vjrPFB/Auo3UKtBNIS7rWnvVwxlQ9swfWGYiew09lrOM6f4HWzsRWObyGYHHxn7T1AX+vys",
	"vQNafge923dtPHzTce3ltQvnPvSaoSwxJ0j02RD8lBbzeWEUEcQCNKIm92E9uQ83zPI60HxFmmLJ6gcG",
	"0UPpRpYLicVATWowcCQ29cXWa/C7p6jHuZQf4gWEDCRlFEHKGE5v7+laD0KTYaO482yFmjv9a9lUei2N",
	"3zAP7kEGgy1WQWkKqo82RfA7oN0xDWRFTOd5bF6ijxnLK8iyMMar0kEykPez14NpgJ5hTb/1AfsogvR4",
	"zHEG6Yd2lvKbVVmRhZG+k9lUSkzAX5Fx8Vqf/qEN25GTOX2pu7P6P/Vv/5vqxqULrABN23lSQV4Wt8vK",
	"wgp9YgpoC/U7s9uvHyHmerZb/AvQiqCoDp0y7FS4G7ykujd7hS+r6zu/TuxWv90tLhm/qGXExo+hOTp5",
	"S5/8VX/zxHBZQpOmvPv4e31jA6jV3e+eEhtv1XIeUJay9oL0vTCkf1PBjdQfaLv37wBtoVH9Fai3kNdu",
	"GY4LaotbyCZcB6Uf0WCnoFqoriNDehUR6DmxnBG9tDX078+QBPNrO79NMTaLgXg87rFe70upVmDRcVgD",
	"Sk+AttVmrIRDtOGlmFHksZGslOF+/bT1BjdikgOfaCSdPM77wtnkcUva+V75FD7LRATUCu7eNmkeNEBE",
	"s5wiPmcjtaWdJ2XbOmo3oXJgeJMX/izlDL9FaR49MA2VbzY8XJYyAvIhe/IaF0rZmKp96jKDG3gHUdtZ",
	"earfntXflNkkg6yP3MAeBtrIyMhR8WvfUbHVTvZoQmueNH9y95JOHgelOeKi+kkvLntNb+hyInHlcvz4",
	"v74jXD6e/N3A4O/eSRw7/o4g/C7xjjBwOR6hrcv/h83LK5duDA2O/5PfaD81xIhvuARGaSv5C0EG6vq/",
	"C9cEoK7s/O3v+sw9oC7+h5RJZq/nQVH9+Px/oh3+Sf0+XDtjZeH7sxDsNQ22W1QvZq4br6jrxsuNuxU2",
	"K8Cn00ICqOsfn/9Pz6fshMwU0lDqvxCgjntdygwNQk1AkK9LtJFkJ5A/vzTJI+iQtYX9wDw27shOgEYX",
	"0vNnOzqORtISn6KIXjkLH2ZCc1ri8NpZQw4EYopuLYKsg0YcXWJ8bQ1WCYU5umueL89KaZGnB7g4bAGT",
	"YDOxL3LiKNTh0Ydcxvp7VLriLW6ZK9l/ePsxnJnFbeUEi5GXy4TSY+Zn9alZz/1XFvNK9pwwZleMB4/b",
	"3aADHot/Lptq1sNpU5bXDHNYWyBn+jgMgtuZGbxY5GSYXwmFk/NSQr3Ww3zHP4io9qQxf6teeY7c7LVG",
	"pbb75HtqeoaFvW4TlKli/dHUTnECPgeNHuMnIkA1fXmq/t1fgXYTt46eJF+qZO+2LDDaV7FuX40nyIq6",
	"hcD2t4Du0EmWq3EKWtBcIrSLxRNKPFxy1tCQ363m0reCvG+0y7UVLnU4T80hFOQUKKpXpJSYd9CSrGxV",
	"33oE1G+JGfwQaewzQC239wyQmmgrQGg04cBDNL8Qr7+PnucGUuMtLKKStW2G0GF4UdjoirigCnKK5y10",
	"UhmNXDMi1EIGs/EBvmTGA14zg+mCNwHXkgfEkTr4uL2GJIN5wg3H7QHb3niFogKsl3bvzzQebO4UJ/T5",
	"b4D6jU2PKKoMj5m67vKY0X5Wa0Ps76vf/7n+fGmn9HoAjgX5AC9mqK8Hqa/tu+ZxT2+STSSahSAnoczj",
	"npvICWGz+YLVKsOKCuXwgXZYqBewyRYuitiPxYNsOzczNaVV0wARpj/7wRQKY/ne2Eu1p8R9Sb8xY/go",
	"1Wr9L1vIT7qED7T1yUWglncqv+i1l/5e3msDR+NHHY6Ea0fi//X5QP87ly5eTP7zWxcvHvX9fOT3w/1H",
	"jvx+mPruv+A/n+Oj7v5L1rF3/yX0OGyB+/m3/vmtt36PXvqXI/Qv/4Ibsn2FnvV0fSA8bWEHN8OdO2KE",
	"o9E1YYSbuwS/EY5eaYMRjoccbIT/9eX2qxmKei2a4g5KcXfcDoP8M2v75uu0OQAxF4i7H2/jHKkCsXTu",
	"GFtxFhUKsvK2eId27DLkmE9bwKEmdl0VlB6SxzGQ1eBepKlwvy6qKSktKaCoZq9cyYsK0BZ21efI8wet",
	"O2SV1nw6RtHuWqaQBuoKCvRbdB0juSQWkcxJcscw1DIZBsJVzpGwQiTMQPgoCd3Ih+1dXcK+8+AFCH/O",
	"ags1CThqxUkB5iyYiIE5rXUW2zueIikT4ZhoFM6y9YVsceWMGCT3kX47WJyDp5kMgknD4o6PxOtti7TV",
	"Fur3f8bnx8Q2gauLImerZiCta//ew7DcUQpykf8ppDyS/Z7hYQsVu7EX4biGpWqbsgcHtBRM1OSquy2b",
	"lty+bQoFIn5MjA22MKDG883diVmk4WM2e1af+gVoc45cAhpHMDm0BXIOh4+drbQb+NN8FWhFw3NY2b09",
	"u7N8m7hRqQdtLicrGeFi5lg8TuU8VOCYtWlHNtSBikba4xXAoShGhNcq8VhX4bKob+xpEHPwb00ja+Ui",
	"NfpzidlcyDGVXd17L3m1A0vORhJ6MX2ApJ0hOO3CFiqfhis8x3i8DcE55NTCsvzxqbh/5KcRKmMPkjEG",
	"5UP6Nh137wPVbefKTmpwzLy5cwIyzZv+zihCBJ+5d/osYZ+PAg61X5/Tpe/Hfe3xcO2D3NlcSWHkbkRQ",
	"Elfbl6NHPN/awvZWrb72tMmZd5XuHUQ2nOfS3Ck8M9/B0sjJKS8O8cVWeJgko1Ha5GnBUvJVKxydeJKr",
	"PakOLXJWa9ZJS4EmnOoXotV5UVBwwYLmOAvXMGg8Luoba43pX+sTM23gJqP0AkfhAqrWAk0BowHmrLN5",
	"Bb7Z9HSxp6nVKTK9O0br9pwn/7ocTtcNc8pmel/I1CTucxGrh5AHIyN0+ZXxaFPJilFOfmFW6HAdqsAR",
	"RK3iH/6HK6x581ZEad9xvI2IYUrnhDvwcNEPWinG2YWQUKRruKzXteyXYpJ5hOFcOe6h2iOBeBKGjxv5",
	"wtoCgPbJMiqz8EIvb6IKA9NAXTkO1OXtjWdAfYnEFwU6+2UX95/4w8lTp/tRUnH/+x/825l/7//jh2c/",
	"+pgV2o0zh4+P97fwkbUCELeawufg7SpYVEmdmGjr8Iz4ywejja68C+ZwIyRuy+JX5uaFty2rTSnTX8iL",
	"QF3ffr3VuFvZ3lgDRVVM55QxoK43nm+i15jhtehF+AV8mCkDF/KiHDpJ3HL1tBQQyaNUWD4ez2Am1ooZ",
	"nfjWDHIunVFVxPHIhQvwoYq+/gbZvw4jNxCkzPH7DsUewOE3EKOwT1r4sywKGfOAwW+MFnAYb3FkLsNh",
	"N1tCwOYe7nhcLU+MLKp8lSjIkjJ2Hr5OlWY6UWCVlnIlZdao4NYVoGpUMRgUiEqXlXAGpTpco3h1V/Tb",
	"s42/zbvL8wzUF3/afvWTfmsC6vdzs/Vvf/CsEJbIZr+URLryVh4fk1iGS06Capa9QATvRqct6JP4NG8R",
	"qM/0N4tGer8241lGw/bKEqmyQ4UmeVZ7QpYNytwsqn41nex1rbjIz1Z3sGbgXgB99oW+ueJLfMSDkLyX",
	"UTEri9xXFSXnKATxvpQSu5XoM0CbsvfAKO6AaydRTm0EQ/ZTDkcYYJUgEZJ6KtnZOhYIJT/7uoDIIXjw",
	"VxC7xllrR/J0DtWqIb/gwV817FhlrRoJ4Do0q3bm1OHYm9ChyDJaPbNgM+zbtkysKkQbxZ3bhgen2/c3",
	"KGFnzTgEj3Vjxixsv/ppe2MamoA4CwlqiKq7zCM+iVbXD6EiBmn38XUusqGT+h7FPpWF3FkxfdmLZK5y",
	"kHZwMDL9tJ+NOh3aAiopsoLEa9FV3PFAEAWaNJKRAZvIZhQhoVjHR8h8iRgHkUhm88Ox2KikXC1cPprI",
	"pmPwd0VSxMRV+GeuP2GyS38e1XeKsEpu0mzVd20QDkpSUqLXj2ZdssggyhQYj0ayOTEj5KTIcGToaPzo",
	"EHZVXUXGWAwVrsVnN6ISaJHpE5Xt13fszO0f3RlB3cuoDumZZGQ48oGonMB9Okr2DsbjoUqYcseqMA6U",
	"gujsnieJN6qRSVbrk/P6tFEmFh8LMWvEOqvDroQgqUeh6vFo5Fh8wGvqJlFjrgqx49HIcUxl/xdZ1Xlp",
	"ax4V1XPCw+eXxi9FI/lCOi3IYwZJ3RTE5INMLIzmkcsYMkPk0ng0ksvmm+JAbYGUblp0Fec9MXIGqOs0",
	"aVH+apkAlTuR1c6tI9k8ZlejRLWYV/6QTY61rdYu7fAZd5ex7m6ZMDPjWpAGfICGY6m5hdBHLOKdL4Ps",
	"8qfV9Nc/6r/N2TRWUv/YVBAMe95WO91hRXgGbnLVFO8CSKBceyw08F1bzEkMYBiPkl0qdgOXix/HKJES",
	"FbE5vNCnpncfLHcCL06hUVmIcZBkmVClJ8s9WW5NljEnsTd56ropj8q81iMx200U4/D9mGHce6uszCCn",
	"0DrqadLNXkgxiYfjEGTm7FrWSSmqLLGDxKyg9C4T2PL2xiwSVYeRXT3AqrN7CRzmByVahjz4aNDMjCsS",
	"dbIYpP0S3uyM/kulkTHV34H2cZTVDZdMmcHbzcoURWEvmaLT0v9hxepYfCj4Rcd9Pnu10/lwBlME6Q0q",
	"Zk4TXbPIFs2Qhf/xdSv63LpzvbQFlBJkq7nrXFKTk3GwYgXVefK+Bsj7whtvTz/SkW8Cdcl+3RAuKeU3",
	"MVwgEmrflhMRD/MOSpkq85nqzusYOoRaXrc+jNvDIhS5ILZq0Ye7XoQt2s3yGD/2OXuwL38VB1ARzTiQ",
	"zQ4U6nGAl+u2r5bhywIoF+mZ+OAGK4R3DsAinm0PtdpT6lHYZAWlK/plaIRUvVFCfOelh08hsAsIr1x4",
	"NNNj+zbs2rbAquB92ypk6KFAswTihnmS7OtyIiECHpoe29/k4Tqi1W034/PYguG8OD0N01PDPBY/1nmy",
	"0Lxz5hRzc3b7j2hfFFnve6HuX9w/7dnlG6INWObOQ5PICu1gU8puVIXec7pmv9kjp07PAO3Jecd8VoFb",
	"bhMOYVP+TZ8wCmZIXG0RNizAMBL6/P1idBJzZ0xMWxdtOBluKzIZNGrxoKiHTD3F5aAoLo466MHOP8p0",
	"iJkF5rjPq8xav3PcZfR8tBpUxm8vD7JsN3E2eajFJEHFu1xiu/Ulvz4P1WnY0N5fHG44BrWF3eLDXfW/",
	"iW/XRAgzkpvlu/TyWFeBNgm0GZvr0aMHKm7X1wleDYoer1CKhRlJzn/I34PppvTO6A1n8gKP5emLqful",
	"pLJTUKiKLKzQRr+jjw9w0Y9Oq6R0DZq9ilts4+ZiK43aJnWW1IP14bybzp3Fowpwl8ZG9c6Ex/j5KZyK",
	"+KU4FlJD1NffkAM1drWM0NqiVZcjHwkLeTlHUZAzmU8KojyGoK/zyEBVtmld2/QqPtJW9dKjk16YVZfL",
	"vr+sBZ4utUWT4IskmQHaFP9Zf+NuxSvhs3F3iS9SjJLC5uHjo0LaBzsG9h07PBig8WATBeA0jQ6kgR46",
	"HD50wBIU+sgZKQWxGzmqrNd4DFXYEvApdItYEg0hljwI1ISWoi3ot2Zxardevs+BMSeM6duwpmOOcRob",
	"+LHAPiVORLDZEB4N9/zhB8of7lEgwMfXUl/8ETIMYh6grnaJM5yDzduDbbh0wqFBtuVf9OmXR/Ck3uLA",
	"tnPoya5GNjSlHqb1MC0sphHOWey2kz5fTveFtaBTPc5zO9ctd7XdB7O7P9yCNsHf5uvfP/KSDYYHhxz0",
	"OeDTeRhTEJ0VAlEygD5RMcp2mGMvqhczqNwg8wW6vMc2qqHpSHu0p8BQVyWoW8i1fdd5E9htVNDsOShV",
	"kRSuo7Ha79OCU/gK2YdmvQ4hlSLVcxCvG0bc5Ww2JQoZyA+uip/GQjiKN9W2N6Z3H8zj0s4U879xXjKz",
	"ir6uER5e1yd/RXWJ8PdB40W3d9lG7F/dmXf0u/dn9JWZ7dezjde1kBOIe90BxBg+vnSMPf44Y/yXOriP",
	"uS6pY/r7PI972n9abPZQqT9+sv3qV7gOm0UEhQ9c97GVD3SOojEZb9/XKCoT65mXaF5aEXTeRdKOKsjD",
	"NQVXAZcUQolP+txzciey7X6mi5md26v6zD1cIdrz9iWmKtbBUzRybVqH0x1JH37C0HLxDnMFSUukLKX7",
	"GoXDwesm0dxcbqoEsRvwv1ApA0brxvk8dR0Hf96AybHBSQPUSVW35grQFDFV8VVS/31PFPIOz9CANNfF",
	"ditdHjxCFbrs3pgRR60/P3F2pSOYm1ZgLoKX3DaR8uYjvXu2GzjCtTugGnWJrd8WcNmHqDkzxI3k1ZZD",
	"hs/hJOuQEXSau5MeOO2JsuGdP2Ep1qH8pFgvCZc5wQFy5H6s4JSJTgeneSvW7YVSfFc3J5wS8jRfSAQ1",
	"4L5uvPvglC6Rte8e1b1W4KgLoosquaYYXRPyBIVirKA0+R5+tkO5cxbB9tPwvFM3PC23mHnjaQtKILp8",
	"vkQczL+B0lR9YxKoW/SdDaZn2O0L9QgNBWqFhKp9Y9Rep4ug2y5B1uha9A0NHdy8qNRvzvnqofj21r0I",
	"2zNvfeYK2jPpQV95EVpZ9VoUj+bpRDQzKtd00PcyZnv41IIzyQ0EHroeEpJ26HtsPywPnFUd96uz6sex",
	"j3tsArXuLM0eBuesvRN7dqGpaVvsYKcuoqSfBpoupBQpJ8hK7EpWTvcnBUUI7dvFmNZ5/y7phxcr21zS",
	"Lhgxe0UFehDZugrHYmI2QHppcvgjfMhwy/Ordc4buGrscYVz9ZkoxK1hZROKqPTnFVkU0uFBwrqovWN6",
	"FacT0IkV8+jvaSio+44V9oU+0Jm0D9vvB+xwJm3VMKh5LrRzagrUnVsHw762TfLAJt/ar1nkxW+7zHdQ",
	"341yPY83BVuF8cAdJJYWsVbYBdvIWTiUDrs7w+qZdhVwr7aSblI7e1tJbyvpbSWd30oYONPNW4mUFkab",
	"9CsHuC3xZbLNuJOrfu5ke/PNepTP4GnvlUsZdRfKp2yjXvt9yuSmX7Y32R4AXus5l3uekzY4l5ks7cBG",
	"LCj77Fcm0MLvUSbi1CZfMly3Zt3JmIKd9icbgNZ5h7LZUQBSdsyXzETKnhe5h4Ute5EdjOuBhJ46m/EZ",
	"/h3ahYy7tlPWRL0w9r6FNnvgN0ad8TiOTcp2xs6nIKF7nMXWkvZs+/2w7QlTHFKrnkzvQNvzCEB4UZnH",
	"K9wedZXPljeQPtiYt28MTXiGfXaHpm8zMMm/F97hEErjnjiGu1KH7G0YvQ2jt2G0dcMI9v122YYhZ42g",
	"4v3M2qCvQWflWhsliIy2nAUd6pXnuw/mjxjR7QZjWYHvb6EE60WgPms8eLVb/osHs+H7s0kfRs4wbhqo",
	"K8Yf2sL2xnT9uw2ECnypJeeyqU6ll5Dm21jzuNV8PbyShGztrWKMF7ioUjkN2gLERK3oSk86hOknWAio",
	"yZNm6SoC6lOTsZ23vVOHJGY/QNNYXW1vFLc3N9FqzZjnLkY3ZXoEVbLAqAFtEqi3TGlzYLlHV72s6J6/",
	"jDMrmoktjt0VoS3TZYY2utgNfHl/y2UQHKNhV0Uw+GR9YHtzc/vVT9sb0xAEMIW3JnaeqegKYQ2VLloC",
	"mop2ILP8AdJLp4nUETGcQ7VCqF0LqpfPkYhzlBGxyjKY21JvsziMm4WDi+izLcJRdlBw8FUPrntw3Wa4",
	"ZtW0MOC607YQBn0/M+iaKOelbKbl9ErmlRl7U2PvMzyFoEp77DptjBusDm7ROddk/nFr0BlMwVmKjn3h",
	"S8diZb1uTevGUiy9U/UDkr7qx8KO3Ycg5r4nsdoFgR115BnuY+F+BysDkk72IN6H6srPeGDAR2cySRld",
	"HUKDwSucuVGp7T75HqiV61Immb2ejyYF+bqUiX4hyFCsjIOL8s7qMu17MrrSNKpKpqeR2iur0sP9NpVV",
	"8QIFT+D3MQViKUERMaq3UnXvUbF+/2c3xPOemn+IBuHE+Q46bTjhlz2vTtbpY3fY0xUPPmYYrxbVEyNn",
	"+q4NoDQDqnRvUWUchTv6t4aGiA+3oiUeX9b+lOv1F55OaaksrJOSYrZTNaX0mXuNu698fSBNZQDNwb81",
	"jej21abSfz7DM9+r9B/UXaj0H0w90ypud/qP2Xwv/af7AZcs1qEw0W2w4IV5SFz22S43qB4iCYisUxck",
	"AWEKdjoJyIC1PXAKkI448LIjbgAmXvaSgHqI2Cbj1cG+HnjoqcLhz+ix0KlAuGsmfcNFd1uYswepQKgz",
	"nlQgk7KdMU0pYOieVCBrSXuR3WEju1sO6yYccUjDug+oMmoP60bowQvJPHlA7dFY+cK6DZgPNuztu0IT",
	"eUA+W0NLeUBoSHuRBxRCb9yTPKCuVCN7u8X+5gH1NoxDt2EE5wHt94aRhfbcYCwhpFKXhcSXnvsCFD4U",
	"ubwC1BqWCxRhW8VSOQO0qYvoBlpoGyKO6juZTYpALRumaWkVlL5BwvgE8fEWOgeuQjGlnbtYZFfRrbfL",
	"CE3R3bc80W8nyRx4rpoz7ymicT3gaPwVKJVsYkulVpgQvr31WF/71jqzcL5V1idvYyc1anuFvqi2Mf1r",
	"fWIGUcVxOm6ejUCi9p28KqRSYmZURBL03CU4+3ECZp8mJdMspsATvIMOyWcQQy2j+eI4+GnEBWSFqvry",
	"L/V7ixwrRFqp6bcm9NpLFAzh2I5raTGfFyDhqvrtTX36uw4AiokI7kuyakB7gUACR/uUgLZO4QGWxSbA",
	"QKBJDCl8JvMJikm0y3g2KXrKtzVIbUGffI62SZy+U7MWwshWWB3548nTQK0hXvxMlKUrEoqrb9xdMjxm",
	"SIpd8rJTWTP3BowlDm7Wbp5MSWJGgRsHYmxtgX7HoOeFcx8CdYMFEkE6J+zOiQ5DWHXxZ2e1RsaB5a3K",
	"jRrGmHdWZ/W5dVB6aOzhEDx4QO6qKCQRE9yIfJjFImuXVvFrIZ1LiZHhyFVFyeWHY7GvjiqykDv6RS4m",
	"5KTYtSGy/Kbj7vdk/n9SxnLie5AtLhbi8cG3E4j4f5KS78HPQwmyGOgTeSabFP+UICtGHrQto/fjf0qL",
	"ytVs8r3zg8ffjpiHYHlFljKjSHbOi0r/yWz2S0n0mmVezKOwjPeEy4nkwODQsXf74G72XuzdvtNf5yRZ",
	"zL/3H2Iy2hc/1ndWGOsbjA8O9g28PTx4bHhgoO+Ds5++23dW+Lr/xKj43uDxdwbj8fi7ff+mKLmPM6mx",
	"d/vOQ11AZIxsvH2gQKOBXYAM3qq5mG+D4r8KZqgNpF44OYiFJRQApLKj2QKSffZ5iCILI30ns6mUmIDf",
	"mMH7jbuvdh//iDd5sl39CLRnLpkjUkGuYXfvfSGOLz7Eo3Vt5scY4uocVLX5Xb3cbVtpt2+WB+COZC7G",
	"hgJlYyMvacqLguIdLKFvrugba77hDqyt6TxqdC/iEGBPPCEItomEdoTY3y6z04ufAfUFiihY1zfWpCRQ",
	"a/Vvb+MQg+7nMMswZDMdk34UT0E28rmBXt9Yw2k3JB/SXQmBMqRxVMySvrF2ZPvNzPBgXN9Yw3w9EMd/",
	"b1CplatAm4LkLg/8/0G4D8EHiip5Er5lNMB48C2g1i5mGo+L+sYasVfWbfnfhgfmMYqFfQPUN9tbj+tl",
	"lQ/1EXd26BpOo3mqTgLuSJLFZGRYkQvieFcJIOaA0BmxdP5rG2XwcB9k791m5FhWNyKYe0zsBvzPOMgN",
	"ZxHiF4MLsyApJwymLew8wRnmAQVNIAefVwSlkO/kjblWLx2U2GBBZQpmy1L5Dx85sr97M7WCbAEs5A2z",
	"28sbOmIdI5RuAe0pKN1Hrs0XhqPezGPk1wEvoD73YguCPfFsQZi1D5CWb3jdySrQQbPUOsPFpdc5lvZ2",
	"jNH+2W3ENvaKOrXQJ59nO1pxAy+teyl3bq/qk7dsdw63erRJk4Yu9sMmkB/UdT1vObmAPcOaJ6eh/mD/",
	"ePcuyCnKY5cwLVO7624QHex4PdufFK+h5xXpqCImrrLfGY7FUtmEkLqazSvDQ/F43P2Y+c0lc9whvMN2",
	"S7pmHpkiVeLWiZEz9vR/kiOPDWp3Kr+jOZrQu/d/3C0+BWrNq9ECRrUAt5Y+Udl+fYcuNxfYsJBMSxlG",
	"y+aRX2AL6DpvnwYchTK42kNVM/zbdBwaczVrZn4FtGzlh3I1a1ym7UsBVECRqzVyj4r/EO+go/ZVvmkb",
	"qRnuFp0H9kfqiyuOqAIHnd8K7FHE2gmrP0fLpnPKNQ6MOgTFjSMG3p4RzDEqaWysYT4MbAfpSuOXxv83",
	"AAD//zxqqwC0NQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
